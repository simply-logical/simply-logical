<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns:m="http://schemas.microsoft.com/office/2004/12/omml"
xmlns:mv="http://macVmlSchemaUri" xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta name=Title content="Part II">
<meta name=Keywords content="">
<meta http-equiv=Content-Type content="text/html; charset=macintosh">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 14">
<meta name=Originator content="Microsoft Word 14">
<link rel=File-List href="Part%20II_files/filelist.xml">
<link rel=Edit-Time-Data href="Part%20II_files/editdata.mso">
<link href="lpn.css" rel="stylesheet">
<link href="jquery-ui.min.css" rel="stylesheet">
<script src="jquery.min.js"></script>
<script src="jquery-ui.min.js"></script>
<script src="lpn.js"></script>
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Part II</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Infolab</o:Author>
  <o:LastAuthor>Peter Flach</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>0</o:TotalTime>
  <o:Created>2015-07-21T15:37:00Z</o:Created>
  <o:LastSaved>2015-07-21T15:37:00Z</o:LastSaved>
  <o:Pages>3</o:Pages>
  <o:Words>13855</o:Words>
  <o:Characters>78977</o:Characters>
  <o:Company>University of Bristol</o:Company>
  <o:Lines>658</o:Lines>
  <o:Paragraphs>185</o:Paragraphs>
  <o:CharactersWithSpaces>92647</o:CharactersWithSpaces>
  <o:Version>14.0</o:Version>
 </o:DocumentProperties>
 <o:OfficeDocumentSettings>
  <o:AllowPNG/>
 </o:OfficeDocumentSettings>
</xml><![endif]-->
<link rel=themeData href="Part%20II_files/themedata.xml">
<!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:TrackMoves>false</w:TrackMoves>
  <w:TrackFormatting/>
  <w:HyphenationZone>0</w:HyphenationZone>
  <w:DoNotHyphenateCaps/>
  <w:DrawingGridHorizontalSpacing>6 pt</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>6 pt</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:ValidateAgainstSchemas>false</w:ValidateAgainstSchemas>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:DoNotUnderlineInvalidXML/>
  <w:DoNotPromoteQF/>
  <w:LidThemeOther>EN-GB</w:LidThemeOther>
  <w:LidThemeAsian>JA</w:LidThemeAsian>
  <w:LidThemeComplexScript>X-NONE</w:LidThemeComplexScript>
  <w:DoNotShadeFormData/>
  <w:Compatibility>
   <w:SpaceForUL/>
   <w:BalanceSingleByteDoubleByteWidth/>
   <w:DoNotLeaveBackslashAlone/>
   <w:ULTrailSpace/>
   <w:DoNotExpandShiftReturn/>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
   <w:DontGrowAutofit/>
   <w:SplitPgBreakAndParaMark/>
  </w:Compatibility>
  <m:mathPr>
   <m:mathFont m:val="Cambria Math"/>
   <m:brkBin m:val="before"/>
   <m:brkBinSub m:val="&#45;-"/>
   <m:smallFrac m:val="off"/>
   <m:dispDef m:val="off"/>
   <m:lMargin m:val="0"/>
   <m:rMargin m:val="0"/>
   <m:defJc m:val="centerGroup"/>
   <m:wrapRight/>
   <m:intLim m:val="subSup"/>
   <m:naryLim m:val="subSup"/>
  </m:mathPr></w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" DefUnhideWhenUsed="true"
  DefSemiHidden="true" DefQFormat="false" DefPriority="99"
  LatentStyleCount="276">
  <w:LsdException Locked="false" Priority="0" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Normal"/>
  <w:LsdException Locked="false" Priority="9" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="heading 1"/>
  <w:LsdException Locked="false" Priority="9" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="heading 2"/>
  <w:LsdException Locked="false" Priority="9" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="heading 3"/>
  <w:LsdException Locked="false" Priority="9" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="heading 4"/>
  <w:LsdException Locked="false" Priority="9" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="heading 5"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 6"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 7"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 8"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 9"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 1"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 2"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 3"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 4"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 5"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 6"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 7"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 8"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 9"/>
  <w:LsdException Locked="false" Priority="35" QFormat="true" Name="caption"/>
  <w:LsdException Locked="false" Priority="10" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Title"/>
  <w:LsdException Locked="false" Priority="1" Name="Default Paragraph Font"/>
  <w:LsdException Locked="false" Priority="11" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Subtitle"/>
  <w:LsdException Locked="false" Priority="22" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Strong"/>
  <w:LsdException Locked="false" Priority="20" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Emphasis"/>
  <w:LsdException Locked="false" Priority="59" SemiHidden="false"
   UnhideWhenUsed="false" Name="Table Grid"/>
  <w:LsdException Locked="false" UnhideWhenUsed="false" Name="Placeholder Text"/>
  <w:LsdException Locked="false" Priority="1" UnhideWhenUsed="false"
   QFormat="true" Name="No Spacing"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 1"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 1"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 1"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 1"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 1"/>
  <w:LsdException Locked="false" UnhideWhenUsed="false" Name="Revision"/>
  <w:LsdException Locked="false" Priority="34" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="List Paragraph"/>
  <w:LsdException Locked="false" Priority="29" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Quote"/>
  <w:LsdException Locked="false" Priority="30" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Intense Quote"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 1"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 1"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 1"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 1"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 1"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 1"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 2"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 2"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 2"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 2"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 2"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 2"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 2"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 2"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 3"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 3"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 3"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 3"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 3"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 3"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 3"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 3"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 4"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 4"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 4"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 4"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 4"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 4"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 4"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 4"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 5"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 5"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 5"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 5"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 5"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 5"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 5"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 5"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 6"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 6"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 6"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 6"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 6"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 6"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 6"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 6"/>
  <w:LsdException Locked="false" Priority="19" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Subtle Emphasis"/>
  <w:LsdException Locked="false" Priority="21" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Intense Emphasis"/>
  <w:LsdException Locked="false" Priority="31" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Subtle Reference"/>
  <w:LsdException Locked="false" Priority="32" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Intense Reference"/>
  <w:LsdException Locked="false" Priority="33" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Book Title"/>
  <w:LsdException Locked="false" Priority="37" Name="Bibliography"/>
  <w:LsdException Locked="false" Priority="39" QFormat="true" Name="TOC Heading"/>
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Times;
	panose-1:2 0 5 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"New York";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:77;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"New York";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:77;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"Avant Garde";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-alt:"Century Gothic";
	mso-font-charset:0;
	mso-generic-font-family:auto;
	mso-font-format:other;
	mso-font-pitch:auto;
	mso-font-signature:0 0 0 0 0 0;}
@font-face
	{font-family:"Lucida Grande";
	panose-1:2 11 6 0 4 5 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:-520090897 1342218751 0 0 447 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
h1
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-parent:"Heading 2";
	mso-style-next:"Heading 2";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:48.0pt;
	margin-left:1.0cm;
	text-align:right;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	border:none;
	mso-border-bottom-alt:solid windowtext 1.5pt;
	padding:0cm;
	mso-padding-alt:0cm 0cm 0cm 0cm;
	font-size:24.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-bidi-font-family:Times;
	mso-font-kerning:0pt;
	mso-ansi-language:EN-US;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-next:sektie1;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:18.0pt;
	margin-left:0cm;
	mso-line-height-alt:15.0pt;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:18.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;
	mso-bidi-font-weight:normal;}
h3
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-parent:"Heading 2";
	mso-style-next:sektie1;
	margin-top:24.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:15.0pt;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Avant Garde";
	mso-bidi-font-family:"Avant Garde";
	mso-ansi-language:EN-US;
	mso-bidi-font-weight:normal;}
h4
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-next:Normal;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:18.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-outline-level:4;
	font-size:12.0pt;
	font-family:Times;
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;
	font-weight:normal;
	text-decoration:underline;
	text-underline:single;}
h5
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-next:Normal;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-outline-level:5;
	font-size:10.0pt;
	font-family:Times;
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.MsoToc1, li.MsoToc1, div.MsoToc1
	{mso-style-unhide:no;
	mso-style-next:Normal;
	margin-top:0cm;
	margin-right:42.5pt;
	margin-bottom:0cm;
	margin-left:14.0pt;
	margin-bottom:.0001pt;
	text-indent:-14.0pt;
	line-height:15.0pt;
	mso-pagination:widow-orphan;
	tab-stops:14.0pt right dotted 425.2pt;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.MsoToc2, li.MsoToc2, div.MsoToc2
	{mso-style-unhide:no;
	mso-style-next:Normal;
	margin-top:0cm;
	margin-right:42.5pt;
	margin-bottom:0cm;
	margin-left:53.0pt;
	margin-bottom:.0001pt;
	text-indent:-17.6pt;
	line-height:15.0pt;
	mso-pagination:widow-orphan;
	tab-stops:53.0pt right dotted 425.2pt;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.MsoToc3, li.MsoToc3, div.MsoToc3
	{mso-style-unhide:no;
	mso-style-next:Normal;
	margin-top:0cm;
	margin-right:42.5pt;
	margin-bottom:0cm;
	margin-left:70.85pt;
	margin-bottom:.0001pt;
	line-height:15.0pt;
	mso-pagination:widow-orphan;
	tab-stops:93.0pt right dotted 425.2pt;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.MsoFootnoteText, li.MsoFootnoteText, div.MsoFootnoteText
	{mso-style-unhide:no;
	mso-style-next:Normal;
	margin-top:0cm;
	margin-right:30.0pt;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:10.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:9.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-unhide:no;
	mso-style-next:Normal;
	margin:0cm;
	margin-bottom:.0001pt;
	line-height:15.0pt;
	mso-pagination:widow-orphan;
	tab-stops:center 185.7pt right 371.4pt;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-unhide:no;
	mso-style-next:Normal;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 212.6pt right 425.2pt;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
span.MsoFootnoteReference
	{mso-style-unhide:no;
	mso-ansi-font-size:8.0pt;
	position:relative;
	top:-3.0pt;
	mso-text-raise:3.0pt;}
span.MsoEndnoteReference
	{mso-style-noshow:yes;
	mso-style-priority:99;
	vertical-align:super;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-link:"Balloon Text Char";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:9.0pt;
	font-family:"Lucida Grande";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.figure, li.figure, div.figure
	{mso-style-name:figure;
	mso-style-unhide:no;
	mso-style-next:Caption1;
	margin-top:18.0pt;
	margin-right:0cm;
	margin-bottom:18.0pt;
	margin-left:0cm;
	text-align:center;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	border:none;
	mso-border-top-alt:solid windowtext .25pt;
	mso-border-bottom-alt:solid windowtext .25pt;
	padding:0cm;
	mso-padding-alt:12.0pt 0cm 12.0pt 0cm;
	mso-element:frame;
	mso-element-frame-hspace:9.0pt;
	mso-element-frame-vspace:9.0pt;
	mso-element-wrap:auto;
	mso-element-anchor-horizontal:column;
	mso-element-left:center;
	mso-element-top:top;
	mso-height-rule:exactly;
	font-size:9.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.med-figure, li.med-figure, div.med-figure
	{mso-style-name:med-figure;
	mso-style-unhide:no;
	mso-style-parent:figure;
	mso-style-next:med-caption;
	margin-top:18.0pt;
	margin-right:1.0cm;
	margin-bottom:18.0pt;
	margin-left:1.0cm;
	text-align:center;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	border:none;
	mso-border-top-alt:solid windowtext .25pt;
	mso-border-bottom-alt:solid windowtext .25pt;
	padding:0cm;
	mso-padding-alt:12.0pt 0cm 12.0pt 0cm;
	mso-element:frame;
	mso-element-frame-hspace:9.0pt;
	mso-element-frame-vspace:9.0pt;
	mso-element-wrap:auto;
	mso-element-anchor-horizontal:column;
	mso-element-left:center;
	mso-element-top:top;
	mso-height-rule:exactly;
	font-size:9.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.med-caption, li.med-caption, div.med-caption
	{mso-style-name:med-caption;
	mso-style-unhide:no;
	mso-style-parent:Caption1;
	mso-style-next:sektie;
	margin-top:0cm;
	margin-right:1.0cm;
	margin-bottom:18.0pt;
	margin-left:1.0cm;
	text-align:center;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	mso-element:frame;
	mso-element-frame-hspace:9.0pt;
	mso-element-frame-vspace:9.0pt;
	mso-element-wrap:auto;
	mso-element-anchor-horizontal:column;
	mso-element-left:center;
	mso-element-top:top;
	mso-height-rule:exactly;
	font-size:9.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.inter-title, li.inter-title, div.inter-title
	{mso-style-name:inter-title;
	mso-style-unhide:no;
	mso-style-parent:intermezzo;
	margin-top:0cm;
	margin-right:1.0cm;
	margin-bottom:6.0pt;
	margin-left:1.0cm;
	text-align:center;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	background:#E5E5E5;
	mso-shading:windowtext;
	mso-pattern:gray-10 auto;
	border:none;
	mso-border-alt:solid windowtext .25pt;
	padding:0cm;
	mso-padding-alt:14.0pt 14.0pt 14.0pt 14.0pt;
	mso-element:frame;
	mso-element-frame-hspace:9.0pt;
	mso-element-frame-vspace:9.0pt;
	mso-element-wrap:auto;
	mso-element-anchor-horizontal:column;
	mso-element-left:center;
	mso-element-top:top;
	mso-height-rule:exactly;
	font-size:9.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.tabel, li.tabel, div.tabel
	{mso-style-name:tabel;
	mso-style-unhide:no;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	line-height:18.0pt;
	mso-pagination:widow-orphan;
	tab-stops:4.0cm 6.0cm 8.0cm 10.0cm 12.0cm;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.bewijs, li.bewijs, div.bewijs
	{mso-style-name:bewijs;
	mso-style-unhide:no;
	mso-style-next:tekst;
	margin-top:0cm;
	margin-right:1.0cm;
	margin-bottom:12.0pt;
	margin-left:1.0cm;
	text-align:justify;
	line-height:15.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:right 14.0cm;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.pi, li.pi, div.pi
	{mso-style-name:pi;
	mso-style-unhide:no;
	mso-style-parent:programma;
	mso-style-next:pi-laatst;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:45.35pt;
	margin-bottom:.0001pt;
	text-indent:-1.0cm;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
p.referenties, li.referenties, div.referenties
	{mso-style-name:referenties;
	mso-style-unhide:no;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:39.65pt;
	margin-bottom:.0001pt;
	text-indent:-41.1pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.email, li.email, div.email
	{mso-style-name:email;
	mso-style-unhide:no;
	mso-style-parent:adres;
	mso-style-next:abstract;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	line-height:10.0pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.adres, li.adres, div.adres
	{mso-style-name:adres;
	mso-style-unhide:no;
	mso-style-next:email;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	line-height:10.0pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.ABSTRACT, li.ABSTRACT, div.ABSTRACT
	{mso-style-name:ABSTRACT;
	mso-style-unhide:no;
	mso-style-parent:auteur;
	mso-style-next:abstract;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	text-align:center;
	line-height:15.0pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	text-transform:uppercase;
	mso-ansi-language:EN-US;
	font-style:italic;
	mso-bidi-font-style:normal;}
p.titel, li.titel, div.titel
	{mso-style-name:titel;
	mso-style-unhide:no;
	mso-style-next:auteur;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	text-align:center;
	mso-line-height-alt:15.0pt;
	mso-pagination:widow-orphan;
	font-size:18.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.sektie, li.sektie, div.sektie
	{mso-style-name:sektie;
	mso-style-unhide:no;
	mso-style-parent:tekst;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:18.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.auteur, li.auteur, div.auteur
	{mso-style-name:auteur;
	mso-style-unhide:no;
	mso-style-next:Normal;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	text-align:center;
	line-height:15.0pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;
	font-style:italic;
	mso-bidi-font-style:normal;}
p.abstract0, li.abstract0, div.abstract0
	{mso-style-name:abstract;
	mso-style-unhide:no;
	mso-style-next:Normal;
	margin-top:6.0pt;
	margin-right:56.65pt;
	margin-bottom:12.0pt;
	margin-left:2.0cm;
	text-align:justify;
	text-indent:14.15pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.opsomming, li.opsomming, div.opsomming
	{mso-style-name:opsomming;
	mso-style-unhide:no;
	mso-style-parent:tekst;
	mso-style-next:tekst;
	margin-top:0cm;
	margin-right:28.3pt;
	margin-bottom:0cm;
	margin-left:39.0pt;
	margin-bottom:.0001pt;
	text-indent:-21.15pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.formule, li.formule, div.formule
	{mso-style-name:formule;
	mso-style-unhide:no;
	margin-top:6.0pt;
	margin-right:-.05pt;
	margin-bottom:6.0pt;
	margin-left:2.0cm;
	line-height:18.0pt;
	mso-pagination:widow-orphan;
	tab-stops:right 398.3pt;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.tekst, li.tekst, div.tekst
	{mso-style-name:tekst;
	mso-style-unhide:no;
	mso-style-next:sektie;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.rep, li.rep, div.rep
	{mso-style-name:rep;
	mso-style-unhide:no;
	mso-style-next:tekst;
	margin-top:3.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	text-align:center;
	line-height:15.0pt;
	mso-pagination:widow-orphan;
	tab-stops:2.0cm right 15.0cm;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.sektie1, li.sektie1, div.sektie1
	{mso-style-name:sektie1;
	mso-style-unhide:no;
	mso-style-parent:sektie;
	mso-style-next:sektie;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.tabel1, li.tabel1, div.tabel1
	{mso-style-name:tabel1;
	mso-style-unhide:no;
	mso-style-parent:tabel;
	margin-top:18.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	text-align:center;
	line-height:18.0pt;
	mso-pagination:widow-orphan;
	tab-stops:4.0cm 6.0cm 8.0cm 10.0cm 12.0cm;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;
	font-style:italic;
	mso-bidi-font-style:normal;}
p.citaat, li.citaat, div.citaat
	{mso-style-name:citaat;
	mso-style-unhide:no;
	mso-style-parent:opsomming;
	margin-top:3.0pt;
	margin-right:17.2pt;
	margin-bottom:3.0pt;
	margin-left:18.0pt;
	text-indent:.35pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.programma, li.programma, div.programma
	{mso-style-name:programma;
	mso-style-unhide:no;
	mso-style-next:tekst;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:17.0pt;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
p.query, li.query, div.query
	{mso-style-name:query;
	mso-style-unhide:no;
	mso-style-parent:pi;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:28.9pt;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
p.exercise, li.exercise, div.exercise
	{mso-style-name:exercise;
	mso-style-unhide:no;
	mso-style-parent:figure;
	mso-style-next:sektie;
	margin-top:18.0pt;
	margin-right:1.0cm;
	margin-bottom:18.0pt;
	margin-left:1.0cm;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:48.0pt 4.0cm;
	border:none;
	mso-border-top-alt:solid windowtext .25pt;
	mso-border-bottom-alt:solid windowtext .25pt;
	padding:0cm;
	mso-padding-alt:6.0pt 0cm 6.0pt 0cm;
	font-size:9.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.intermezzo, li.intermezzo, div.intermezzo
	{mso-style-name:intermezzo;
	mso-style-unhide:no;
	mso-style-parent:figure;
	margin-top:0cm;
	margin-right:1.0cm;
	margin-bottom:18.0pt;
	margin-left:1.0cm;
	text-align:center;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	background:#E5E5E5;
	mso-shading:windowtext;
	mso-pattern:gray-10 auto;
	border:none;
	mso-border-alt:solid windowtext .25pt;
	padding:0cm;
	mso-padding-alt:14.0pt 14.0pt 14.0pt 14.0pt;
	mso-element:frame;
	mso-element-frame-hspace:9.0pt;
	mso-element-frame-vspace:9.0pt;
	mso-element-wrap:auto;
	mso-element-anchor-horizontal:column;
	mso-element-left:center;
	mso-element-top:top;
	mso-height-rule:exactly;
	font-size:9.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.cijfer, li.cijfer, div.cijfer
	{mso-style-name:cijfer;
	mso-style-unhide:no;
	mso-style-next:"Heading 2";
	margin-top:96.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	page-break-before:always;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	font-size:48.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.p-eerst, li.p-eerst, div.p-eerst
	{mso-style-name:p-eerst;
	mso-style-unhide:no;
	mso-style-parent:programma;
	mso-style-next:programma;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:17.0pt;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
p.p-laatst, li.p-laatst, div.p-laatst
	{mso-style-name:p-laatst;
	mso-style-unhide:no;
	mso-style-parent:p-el;
	mso-style-next:tekst;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:17.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
p.motto, li.motto, div.motto
	{mso-style-name:motto;
	mso-style-unhide:no;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:12.0pt;
	margin-left:0cm;
	text-align:right;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.p-el, li.p-el, div.p-el
	{mso-style-name:p-el;
	mso-style-unhide:no;
	mso-style-parent:programma;
	mso-style-next:tekst;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:17.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
p.pi-el, li.pi-el, div.pi-el
	{mso-style-name:pi-el;
	mso-style-unhide:no;
	mso-style-parent:pi;
	mso-style-next:tekst;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:45.35pt;
	text-indent:-1.0cm;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
p.small-caption, li.small-caption, div.small-caption
	{mso-style-name:small-caption;
	mso-style-unhide:no;
	mso-style-parent:Caption1;
	mso-style-next:sektie;
	margin-top:0cm;
	margin-right:1.0cm;
	margin-bottom:18.0pt;
	margin-left:1.0cm;
	text-align:center;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	mso-element:frame;
	mso-element-frame-hspace:9.0pt;
	mso-element-frame-vspace:9.0pt;
	mso-element-wrap:auto;
	mso-element-anchor-horizontal:column;
	mso-element-left:center;
	mso-element-top:top;
	mso-height-rule:exactly;
	font-size:9.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.romeinscijfer, li.romeinscijfer, div.romeinscijfer
	{mso-style-name:"romeins cijfer";
	mso-style-unhide:no;
	mso-style-parent:cijfer;
	mso-style-next:"Heading 1";
	margin-top:60.0pt;
	margin-right:0cm;
	margin-bottom:40.0pt;
	margin-left:0cm;
	text-align:right;
	page-break-before:always;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	font-size:100.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.pi-eerst, li.pi-eerst, div.pi-eerst
	{mso-style-name:pi-eerst;
	mso-style-unhide:no;
	mso-style-parent:pi;
	mso-style-next:pi;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:45.35pt;
	margin-bottom:.0001pt;
	text-indent:-1.0cm;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
p.pi-laatst, li.pi-laatst, div.pi-laatst
	{mso-style-name:pi-laatst;
	mso-style-unhide:no;
	mso-style-parent:pi-el;
	mso-style-next:tekst;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:45.35pt;
	text-indent:-1.0cm;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
p.prolog, li.prolog, div.prolog
	{mso-style-name:prolog;
	mso-style-unhide:no;
	mso-style-parent:tekst;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:2.0cm;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.oms-eerst, li.oms-eerst, div.oms-eerst
	{mso-style-name:oms-eerst;
	mso-style-unhide:no;
	mso-style-parent:p-eerst;
	mso-style-next:pi;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:17.0pt;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:140.0pt;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
p.oms, li.oms, div.oms
	{mso-style-name:oms;
	mso-style-unhide:no;
	mso-style-parent:oms-eerst;
	mso-style-next:pi;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:17.0pt;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:140.0pt;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
p.Caption1, li.Caption1, div.Caption1
	{mso-style-name:Caption1;
	mso-style-unhide:no;
	mso-style-parent:figure;
	mso-style-next:sektie;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:18.0pt;
	margin-left:0cm;
	text-align:center;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	mso-element:frame;
	mso-element-frame-hspace:9.0pt;
	mso-element-frame-vspace:9.0pt;
	mso-element-wrap:auto;
	mso-element-anchor-horizontal:column;
	mso-element-left:center;
	mso-element-top:top;
	mso-height-rule:exactly;
	font-size:9.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.small-figure, li.small-figure, div.small-figure
	{mso-style-name:small-figure;
	mso-style-unhide:no;
	mso-style-parent:figure;
	mso-style-next:small-caption;
	margin-top:18.0pt;
	margin-right:1.0cm;
	margin-bottom:18.0pt;
	margin-left:1.0cm;
	text-align:center;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	border:none;
	mso-border-top-alt:solid windowtext .25pt;
	mso-border-bottom-alt:solid windowtext .25pt;
	padding:0cm;
	mso-padding-alt:12.0pt 0cm 12.0pt 0cm;
	mso-element:frame;
	mso-element-frame-hspace:9.0pt;
	mso-element-frame-vspace:9.0pt;
	mso-element-wrap:auto;
	mso-element-anchor-horizontal:column;
	mso-element-left:center;
	mso-element-top:top;
	mso-height-rule:exactly;
	font-size:9.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.algoritme, li.algoritme, div.algoritme
	{mso-style-name:algoritme;
	mso-style-unhide:no;
	margin-top:0cm;
	margin-right:1.0cm;
	margin-bottom:0cm;
	margin-left:2.0cm;
	margin-bottom:.0001pt;
	text-indent:-1.0cm;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:right 14.0cm;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.stelling, li.stelling, div.stelling
	{mso-style-name:stelling;
	mso-style-unhide:no;
	mso-style-parent:tekst;
	margin-top:12.0pt;
	margin-right:1.0cm;
	margin-bottom:0cm;
	margin-left:1.0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	tab-stops:right 14.0cm;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;
	font-style:italic;
	mso-bidi-font-style:normal;}
p.s2, li.s2, div.s2
	{mso-style-name:s2;
	mso-style-unhide:no;
	mso-style-parent:bewijs;
	margin-top:0cm;
	margin-right:1.0cm;
	margin-bottom:0cm;
	margin-left:1.0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	line-height:15.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:right 14.0cm;
	font-size:10.0pt;
	font-family:Times;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Times;
	mso-ansi-language:EN-US;}
p.grammar, li.grammar, div.grammar
	{mso-style-name:grammar;
	mso-style-unhide:no;
	mso-style-parent:p-el;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:17.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	tab-stops:5.0cm 197.0pt 9.0cm 11.0cm 13.0cm;
	font-size:10.0pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:Courier;
	mso-ansi-language:EN-US;}
span.BalloonTextChar
	{mso-style-name:"Balloon Text Char";
	mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-unhide:no;
	mso-style-locked:yes;
	mso-style-link:"Balloon Text";
	mso-ansi-font-size:9.0pt;
	mso-bidi-font-size:9.0pt;
	font-family:"Lucida Grande";
	mso-ascii-font-family:"Lucida Grande";
	mso-hansi-font-family:"Lucida Grande";
	mso-bidi-font-family:"Lucida Grande";
	mso-ansi-language:EN-US;}
.MsoChpDefault
	{mso-style-type:export-only;
	mso-default-props:yes;
	font-size:10.0pt;
	mso-ansi-font-size:10.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"New York","serif";
	mso-ascii-font-family:"New York";
	mso-hansi-font-family:"New York";}
 /* Page Definitions */
@page
	{mso-page-border-surround-header:no;
	mso-page-border-surround-footer:no;
	mso-footnote-separator:url(":Part II_files:header.htm") fs;
	mso-footnote-continuation-separator:url(":Part II_files:header.htm") fcs;
	mso-endnote-separator:url(":Part II_files:header.htm") es;
	mso-endnote-continuation-separator:url(":Part II_files:header.htm") ecs;
	mso-facing-pages:yes;
	mso-footnote-numbering-start:12;}
@page WordSection1
	{size:595.0pt 842.0pt;
	margin:-5.0cm 112.0pt -138.9pt 112.0pt;
	mso-header-margin:104.9pt;
	mso-footer-margin:36.0pt;
	mso-page-numbers:79;
	mso-title-page:yes;
	mso-even-header:url(":Part II_files:header.htm") eh1;
	mso-header:url(":Part II_files:header.htm") h1;
	mso-paper-source:0;}
div.WordSection1
	{page:WordSection1;
	mso-footnote-numbering-start:12;}
@page WordSection2
	{size:595.0pt 842.0pt;
	margin:-5.0cm 112.0pt -138.9pt 112.0pt;
	mso-header-margin:104.9pt;
	mso-footer-margin:36.0pt;
	mso-title-page:yes;
	mso-even-header:url(":Part II_files:header.htm") eh1;
	mso-header:url(":Part II_files:header.htm") h2;
	mso-first-header:url(":Part II_files:header.htm") fh2;
	mso-paper-source:0;}
div.WordSection2
	{page:WordSection2;
	mso-footnote-numbering-start:12;}
@page WordSection3
	{size:595.0pt 842.0pt;
	margin:-5.0cm 112.0pt -138.9pt 112.0pt;
	mso-header-margin:104.9pt;
	mso-footer-margin:36.0pt;
	mso-title-page:yes;
	mso-even-header:url(":Part II_files:header.htm") eh1;
	mso-header:url(":Part II_files:header.htm") h3;
	mso-first-header:url(":Part II_files:header.htm") fh3;
	mso-paper-source:0;}
div.WordSection3
	{page:WordSection3;
	mso-footnote-numbering-start:12;}
@page WordSection4
	{size:595.0pt 842.0pt;
	margin:-5.0cm 112.0pt -138.9pt 112.0pt;
	mso-header-margin:104.9pt;
	mso-footer-margin:36.0pt;
	mso-title-page:yes;
	mso-even-header:url(":Part II_files:header.htm") eh4;
	mso-header:url(":Part II_files:header.htm") h4;
	mso-first-header:url(":Part II_files:header.htm") fh4;
	mso-paper-source:0;}
div.WordSection4
	{page:WordSection4;
	mso-footnote-numbering-start:12;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"New York","serif";}
</style>
<![endif]-->
</head>

<body bgcolor=white lang=EN-GB style='tab-interval:28.0pt'>

<div class=WordSection1>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;optimality:see also:A* algorithm&quot;
\t &quot;&quot; \i </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;optimality:see also:breadth-first
search&quot; \t &quot;&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;optimality:see also:depth-first
search&quot; \t &quot;&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;optimality:see also:iterative
deepening&quot; \t &quot;&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;backtracking:see also Prolog&quot;
\t &quot;&quot; \i </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;time complexity,&quot; \t &quot;see
depth-first search&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;optimistic heuristic,&quot; \t
&quot;see heuristic&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;pessimistic heuristic,&quot; \t
&quot;see heuristic&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;monotonicity:of heuristic,&quot; \t
&quot;see heuristic&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;informedness,&quot; \t &quot;see
heuristic&quot; \i </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;admissibility,&quot; \t &quot;see
heuristic&quot; \i </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;range-restricted clause,&quot; \t
&quot;see clause&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=romeinscijfer><span lang=EN-US>II</span></p>

<div style='mso-element:para-border-div;border:none;border-bottom:solid windowtext 1.5pt;
padding:0cm 0cm 0cm 0cm;margin-left:28.0pt;margin-right:0cm'>

<h1 style='margin-left:0cm'><span lang=EN-US>Reasoning with <br>
structured knowledge</span></h1>

</div>

<p class=sektie1><span lang=EN-US>A physical object is <i style='mso-bidi-font-style:
normal'>structured</i> if it consists of several components having certain
spatial relationships to each other. Likewise, knowledge is structured if its
components have certain logical relationships. For instance, a description of
the London underground system consists of a list of stations (the components)
plus a list of connections between stations (the relationships). As can be seen
in fig. 1.1 in Chapter 1, such structured knowledge has a convenient graphical
representation, in which components are represented by points or <i
style='mso-bidi-font-style:normal'>node</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;node&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US>, and relationships are represented by lines or <i style='mso-bidi-font-style:
normal'>arc</i></span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;arc&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US> between nodes. In mathematics, such graphical structures are called
<i style='mso-bidi-font-style:normal'>graph</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;graph&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>A characteristic property of structured
knowledge</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;structured
knowledge&quot; \b </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is the distinction that
is made between <i style='mso-bidi-font-style:normal'>explicit</i> and <i
style='mso-bidi-font-style:normal'>implicit</i> relationships. For instance, in
the underground example the direct connections which exist between two stations
are the explicit relationships. All other relationships (i.e. connections
between stations that are further apart) are only implicitly represented, and
must be reconstructed from the explicit relationships. Therefore, <i
style='mso-bidi-font-style:normal'>reasoning</i> forms an integral part of any
form of structured knowledge. </span></p>

<p class=sektie><span lang=EN-US>Other examples of structured knowledge,
encountered in Part I, include Prolog terms, proof tree</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;proof
tree&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s, and SLD-tree</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;SLD-tree&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s. Among these, SLD-trees constitute a special case, since they are
not given <i style='mso-bidi-font-style:normal'>a priori</i> as part of the
knowledge describing a certain Universe of Discourse</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Universe
of Discourse&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, but are instead <i style='mso-bidi-font-style:normal'>derived</i>
from problem specifications of the form given program <i style='mso-bidi-font-style:
normal'>P</i>, find all answers to query <i style='mso-bidi-font-style:normal'>Q</i>.
By means of SLD-trees, such problems are translated to problems of the form
given SLD-tree <i style='mso-bidi-font-style:normal'>T</i>, find all paths
from the root of the tree to the empty clause. Problems of the latter kind are
called <i style='mso-bidi-font-style:normal'>search problem</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;search problem&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US>, and the graph being searched is called a <i style='mso-bidi-font-style:
normal'>search space</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;search space&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>.</span></i><span
lang=EN-US> Most problems in intelligent reasoning are search problems of one
kind or the other. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=med-figure style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm'><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shapetype
   id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
   path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
   <v:stroke joinstyle="miter"/>
   <v:formulas>
    <v:f eqn="if lineDrawn pixelLineWidth 0"/>
    <v:f eqn="sum @0 1 0"/>
    <v:f eqn="sum 0 0 @1"/>
    <v:f eqn="prod @2 1 2"/>
    <v:f eqn="prod @3 21600 pixelWidth"/>
    <v:f eqn="prod @3 21600 pixelHeight"/>
    <v:f eqn="sum @0 0 1"/>
    <v:f eqn="prod @6 1 2"/>
    <v:f eqn="prod @7 21600 pixelWidth"/>
    <v:f eqn="sum @8 21600 0"/>
    <v:f eqn="prod @7 21600 pixelHeight"/>
    <v:f eqn="sum @10 21600 0"/>
   </v:formulas>
   <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
   <o:lock v:ext="edit" aspectratio="t"/>
  </v:shapetype><v:shape id="Picture_x0020_1" o:spid="_x0000_i1035" type="#_x0000_t75"
   style='width:228pt;height:84pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20II_files/image001.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=230 height=86
  src="Part%20II_files/image002.png" v:shapes="Picture_x0020_1"><![endif]></span><span
  lang=EN-US><br>
  <br>
  (<i style='mso-bidi-font-style:normal'>a</i>) Starting position<br>
  <br>
  <br>
  <span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape id="Picture_x0020_2"
   o:spid="_x0000_i1034" type="#_x0000_t75" style='width:228pt;height:84pt;
   visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20II_files/image003.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=230 height=86
  src="Part%20II_files/image004.png" v:shapes="Picture_x0020_2"><![endif]></span><br>
  <br>
  (<i style='mso-bidi-font-style:normal'>b</i>) Intermediate position<br>
  <br>
  <br>
  <span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape id="Picture_x0020_3"
   o:spid="_x0000_i1033" type="#_x0000_t75" style='width:228pt;height:84pt;
   visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20II_files/image005.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=230 height=86
  src="Part%20II_files/image006.png" v:shapes="Picture_x0020_3"><![endif]></span><br>
  <br>
  (<i style='mso-bidi-font-style:normal'>c</i>) Goal position</span></p>
  </div>
  <p class=med-caption><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  II.1.</span></b><span lang=EN-US> The Towers of Hanoi.</span></p>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>In principle, any given problem can be defined
as a search problem. To this end, we must identify: </span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>i</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>the nodes in the search
space;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>ii</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>the arcs between nodes;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>iii</i>)<span
style='mso-tab-count:1'>&nbsp; </span>the starting node;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>iv</i>)<span
style='mso-tab-count:1'>&nbsp; </span>the goal node.</span></p>

<p class=tekst><span lang=EN-US>For instance, when searching for an answer to a
query by means of SLD-resolution</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;SLD-resolution&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, the nodes in the search space are resolvents, the arcs are
resolution steps by means of a program clause, the starting node is the query,
and the goal node is the empty clause. As another example, we consider the
puzzle known as <i style='mso-bidi-font-style:normal'>The Towers of Hanoi</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Towers of Hanoi&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. This puzzle consists of three pegs and <i style='mso-bidi-font-style:
normal'>n</i> disks of decreasing size. Initially, all the disks are on the
left peg, such that no disk is placed on a smaller one. This rule is to be
obeyed throughout the game. The goal is to move all the disks to the right peg
by moving one disk at a time. This problem is easily reformulated as a search
problem, where nodes are allowed positions, and arcs are moves of the upper
disk on one peg to another. Starting node and goal node are as in fig. II.1. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .25pt;padding:14.0pt 14.0pt 14.0pt 14.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto;
  margin-left:1.0cm;margin-right:1.0cm'>
  <p class=inter-title style='margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>An analytic solution to the Towers of Hanoi</span></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>In the case of the Towers of Hanoi, there is a
  simple analytic solution based on the following observation: suppose we are
  able to solve the problem for <i style='mso-bidi-font-style:normal'>n</i>&#8211;1
  disks, then we can solve it for <i style='mso-bidi-font-style:normal'>n</i>
  disks also: move the upper <i style='mso-bidi-font-style:normal'>n</i>&#8211;1
  disks from the left to the middle peg</span><a style='mso-footnote-id:ftn1'
  href="#_ftn1" name="_ftnref1" title=""><span class=MsoFootnoteReference><span
  lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span
  style='mso-special-character:footnote'><![if !supportFootnotes]><span
  class=MsoFootnoteReference><span lang=EN-US style='font-size:8.0pt;
  mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";
  mso-bidi-font-family:Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;
  mso-bidi-language:AR-SA'>[12]</span></span><![endif]></span></span></span></a><span
  lang=EN-US>, move the remaining disk on the left peg to the right peg, and
  move the <i style='mso-bidi-font-style:normal'>n</i>&#8211;1 disks from the
  middle peg to the right peg. Since we are able to solve the problem for 0
  disks, it follows by complete induction that we can solve the problem for any
  number of disks. The inductive nature of this argument is nicely reflected in
  the following recursive program:</span></p>
  <p class=intermezzo align=left style='margin:0cm;margin-bottom:.0001pt;
  text-align:left;tab-stops:41.0pt 185.0pt;background:#E5E5E5;mso-shading:windowtext;
  mso-pattern:gray-10 auto'><span lang=EN-US style='font-family:Courier'><span
  style='mso-tab-count:1'>&nbsp;&nbsp; </span>:-op(900,xfx,to).<o:p></o:p></span></p>
  <p class=intermezzo align=left style='margin:0cm;margin-bottom:.0001pt;
  text-align:left;tab-stops:41.0pt 171.0pt;background:#E5E5E5;mso-shading:windowtext;
  mso-pattern:gray-10 auto'><span lang=EN-US style='font-family:Courier'><span
  style='mso-tab-count:1'>&nbsp;&nbsp; </span>% hanoi(N,A,B,C,Moves) &lt;-<span
  style='mso-tab-count:1'> </span>Moves is the list of moves to <br>
  <span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%<span style='mso-tab-count:
  1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>move
  N disks from peg A to peg C, <br>
  <span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%<span style='mso-tab-count:
  1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>using
  peg B as intermediary peg <o:p></o:p></span></p>
  <p class=intermezzo align=left style='margin:0cm;margin-bottom:.0001pt;
  text-align:left;tab-stops:41.0pt 185.0pt;background:#E5E5E5;mso-shading:windowtext;
  mso-pattern:gray-10 auto'><span lang=EN-US style='font-family:Courier'><span
  style='mso-tab-count:1'>&nbsp;&nbsp; </span>hanoi</span><!--[if supportFields]><span
  lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
  style='mso-element:field-begin'></span> XE </span><span lang=EN-US
  style='font-family:Courier'><span
  style="mso-spacerun:yes">&nbsp;</span>&quot;hanoi/5&quot; </span><![endif]--><!--[if supportFields]><span
  lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
  style='mso-element:field-end'></span></span><![endif]--><span lang=EN-US
  style='font-family:Courier'>(0,A,B,C,[]).<o:p></o:p></span></p>
  <p class=intermezzo align=left style='margin-top:0cm;margin-right:0cm;
  margin-bottom:6.0pt;margin-left:57.65pt;text-align:left;text-indent:-57.65pt;
  tab-stops:41.0pt 185.0pt;background:#E5E5E5;mso-shading:windowtext;
  mso-pattern:gray-10 auto'><span lang=EN-US style='font-family:Courier'><span
  style='mso-tab-count:1'>&nbsp;&nbsp; </span>hanoi(N,A,B,C,Moves):-<br>
  N1 is N-1,<br>
  hanoi(N1,A,C,B,Moves1),<br>
  hanoi(N1,B,A,C,Moves2),<br>
  append(Moves1,[A to C|Moves2],Moves).<o:p></o:p></span></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>For instance, the query </span><span
  lang=EN-US style='font-family:Courier'>?-hanoi(3,left,middle,right,M)</span><span
  lang=EN-US> yields the answer</span></p>
  <p class=intermezzo align=left style='margin-top:0cm;margin-right:0cm;
  margin-bottom:6.0pt;margin-left:43.65pt;text-align:left;text-indent:-43.65pt;
  tab-stops:42.0pt 185.0pt;background:#E5E5E5;mso-shading:windowtext;
  mso-pattern:gray-10 auto'><span lang=EN-US style='font-family:Courier'><span
  style='mso-tab-count:1'>&nbsp;&nbsp; </span>M = [<span style='mso-tab-count:
  1'> </span>left to right, left to middle, right to middle, <br>
  left to right, <br>
  middle to left, middle to right, left to right ]<o:p></o:p></span></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>The first three moves move the upper two disks
  from the left to the middle peg, then the largest disk is moved to the right
  peg, and again three moves are needed to move the two disks on the middle peg
  to the right peg. </span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>Since the number of allowed positions is 3</span><i
style='mso-bidi-font-style:normal'><span lang=EN-US style='font-size:9.0pt;
position:relative;top:-3.0pt;mso-text-raise:3.0pt'>n</span></i><span
lang=EN-US>, the search space for the Towers of Hanoi grows exponentially with
the number of disks. In practice, this means that the problem will be
unsolvable for large <i style='mso-bidi-font-style:normal'>n</i>, no matter how
efficient the search program, or how powerful the computer. <i
style='mso-bidi-font-style:normal'>This is a common characteristic of search
problems</i>. Search is a problem solving method which, although applicable to
almost any problem, has considerable practical limitations. Therefore, search
is only applied to problems for which no analytic solutions are known. </span></p>

<p class=sektie><span lang=EN-US>For many problems in intelligent reasoning
such analytic solutions simply do not exist, and search is the best we can do.
In Chapters 5 and 6, we will present and analyse various methods for searching
graphs. Since graphs are not only important for search problems, but for all
forms of structured knowledge, Chapter 4 is devoted to a discussion of various
ways to represent structured knowledge in clausal logic. </span></p>

</div>

<b style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-size:18.0pt;
mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA'><br clear=all style='page-break-before:right;
mso-break-type:section-break'>
</span></b>

<div class=WordSection2>

<p class=cijfer><span lang=EN-US>4</span></p>

<h2><span lang=EN-US>Representing structured knowledge</span></h2>

<p class=sektie1><span lang=EN-US>In this chapter we will discuss various ways
to represent structured knowledge in Prolog. The central notion is that of a <i
style='mso-bidi-font-style:normal'>graph</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;graph&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, which is the mathematical abstraction of the graphical
representation of structured knowledge. A graph consists of <i
style='mso-bidi-font-style:normal'>node</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;node&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US>, and <i style='mso-bidi-font-style:normal'>arc</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;arc&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US> between nodes. Nodes are identified by their name, and arcs are
identified by the pair of nodes they connect. By convention, arcs are taken to
be </span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;directed arc&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>directed</span></i><span
lang=EN-US>, which means that an arc from <i style='mso-bidi-font-style:normal'>n</i></span><span
lang=EN-US style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:
-2.0pt'>1</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>to
<i style='mso-bidi-font-style:normal'>n</i></span><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>2</span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is not the same as an
arc from <i style='mso-bidi-font-style:normal'>n</i></span><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>2</span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>to <i style='mso-bidi-font-style:
normal'>n</i></span><span lang=EN-US style='font-size:9.0pt;position:relative;
top:2.0pt;mso-text-raise:-2.0pt'>1</span><span lang=EN-US>. </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;undirected arc&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>Undirected arcs (as in the London Underground example</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;London
Underground example&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of Chapter 1) can be
viewed as consisting of two directed arcs, one in each direction. If an arc is
directed from <i style='mso-bidi-font-style:normal'>n</i></span><span
lang=EN-US style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:
-2.0pt'>1</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>to
<i style='mso-bidi-font-style:normal'>n</i></span><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>2</span><span
lang=EN-US>, then <i style='mso-bidi-font-style:normal'>n</i></span><span
lang=EN-US style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:
-2.0pt'>1</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is
called the <i style='mso-bidi-font-style:normal'>parent</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;parent&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of <i style='mso-bidi-font-style:
normal'>n</i></span><span lang=EN-US style='font-size:9.0pt;position:relative;
top:2.0pt;mso-text-raise:-2.0pt'>2</span><span lang=EN-US>, and <i
style='mso-bidi-font-style:normal'>n</i></span><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>2</span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is called the <i
style='mso-bidi-font-style:normal'>child</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;child&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of <i style='mso-bidi-font-style:
normal'>n</i></span><span lang=EN-US style='font-size:9.0pt;position:relative;
top:2.0pt;mso-text-raise:-2.0pt'>1</span><span lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>A <i style='mso-bidi-font-style:normal'>path</i>
in a graph</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;path</span></i><span lang=EN-US> in
a graph<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is a sequence of nodes,
such that for each consecutive pair <i style='mso-bidi-font-style:normal'>n</i></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US style='font-size:9.0pt;
position:relative;top:2.0pt;mso-text-raise:-2.0pt'>i</span></i><span
lang=EN-US>, <i style='mso-bidi-font-style:normal'>n</i></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US style='font-size:9.0pt;
position:relative;top:2.0pt;mso-text-raise:-2.0pt'>j</span></i><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>in the sequence the
graph contains an arc from <i style='mso-bidi-font-style:normal'>n</i></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US style='font-size:9.0pt;
position:relative;top:2.0pt;mso-text-raise:-2.0pt'>i</span></i><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>to <i style='mso-bidi-font-style:
normal'>n</i></span><i style='mso-bidi-font-style:normal'><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>j</span></i><span
lang=EN-US>. If there is a path from <i style='mso-bidi-font-style:normal'>n</i></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US style='font-size:9.0pt;
position:relative;top:2.0pt;mso-text-raise:-2.0pt'>k</span></i><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>to <i style='mso-bidi-font-style:
normal'>n</i></span><i style='mso-bidi-font-style:normal'><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>l</span></i><span
lang=EN-US>, then <i style='mso-bidi-font-style:normal'>n</i></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US style='font-size:9.0pt;
position:relative;top:2.0pt;mso-text-raise:-2.0pt'>k</span></i><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is called an <i
style='mso-bidi-font-style:normal'>ancestor</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;ancestor&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of <i style='mso-bidi-font-style:
normal'>n</i></span><i style='mso-bidi-font-style:normal'><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>l</span></i><span
lang=EN-US>, and <i style='mso-bidi-font-style:normal'>n</i></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US style='font-size:9.0pt;
position:relative;top:2.0pt;mso-text-raise:-2.0pt'>l</span></i><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is called a <i
style='mso-bidi-font-style:normal'>descendant</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;descendant&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of <i style='mso-bidi-font-style:
normal'>n</i></span><i style='mso-bidi-font-style:normal'><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>k</span></i><span
lang=EN-US>. A <i style='mso-bidi-font-style:normal'>cycle</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;cycle</span></i><span lang=EN-US>
in a graph<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is a path from a node to
itself. Obviously, when a path from <i style='mso-bidi-font-style:normal'>n</i></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US style='font-size:9.0pt;
position:relative;top:2.0pt;mso-text-raise:-2.0pt'>i</span></i><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>to <i style='mso-bidi-font-style:
normal'>n</i></span><i style='mso-bidi-font-style:normal'><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>j</span></i><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>passes through a node
which is also on a cycle, there are infinitely many different paths from <i
style='mso-bidi-font-style:normal'>n</i></span><i style='mso-bidi-font-style:
normal'><span lang=EN-US style='font-size:9.0pt;position:relative;top:2.0pt;
mso-text-raise:-2.0pt'>i</span></i><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>to <i style='mso-bidi-font-style:normal'>n</i></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US style='font-size:9.0pt;
position:relative;top:2.0pt;mso-text-raise:-2.0pt'>j</span></i><span
lang=EN-US>. Thus, a graph consisting of a limited number of nodes and arcs can
generate infinite behaviour. This is something to keep in mind when searching
such cyclic graphs! </span></p>

<p class=sektie><span lang=EN-US>A <i style='mso-bidi-font-style:normal'>tree</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;tree&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is a special kind of
graph which contains a <i style='mso-bidi-font-style:normal'>root</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;root</span></i><span lang=EN-US> of
a tree<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>such that there is a <b
style='mso-bidi-font-weight:normal'>unique</b> path from the root to any other
node. From this it follows that for any two nodes in a tree, either there is no
path between them, or there is exactly one. Thus, trees are necessarily
non-cyclic or <i style='mso-bidi-font-style:normal'>acyclic</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;acyclic</span></i><span lang=EN-US>
graph<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;graph:acyclic&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. A <i style='mso-bidi-font-style:normal'>leaf</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;leaf&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is a node without
children. Often, leaves are goal nodes in search spaces like SLD-trees.
Strictly speaking, an SLD-tree</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;SLD-tree&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is not a tree, because
there might be several ways to construct the same resolvent. By convention,
however, resolvent</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;resolvent&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s constructed in a different way are considered to be distinct nodes
in the SLD-tree. Usually, trees are drawn upside down, with the root node at
the top; arcs are implicitly understood to be directed from top to bottom. Note
that, if <i style='mso-bidi-font-style:normal'>n</i> is the root of a tree,
each of its children is the root of a <i style='mso-bidi-font-style:normal'>subtree</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;subtree&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>(fig. 4.1).</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=med-figure style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm'></p>
  </div>
  <p class=med-caption><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  4.1.</span></b><span lang=EN-US> A tree with two subtrees.</span></p>
  </td>
 </tr>
</table>

</div>

<h3><span lang=EN-US>4.1<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Trees
as terms</span></h3>

<p class=sektie1><span lang=EN-US>Recall from section 1.3 that complex Prolog
terms like</span></p>

<p class=tekst align=center style='margin-top:3.0pt;margin-right:0cm;
margin-bottom:3.0pt;margin-left:0cm;text-align:center'><span lang=EN-US
style='font-family:Courier'>route(tottenham_court_road,route(leicester_square,noroute))</span></p>

<p class=tekst><span lang=EN-US>can be viewed as a tree</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;term:
as a tree&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, with the functor </span><span lang=EN-US style='font-family:Courier'>route</span><span
lang=EN-US> acting as the root of (sub)trees, and </span><span lang=EN-US
style='font-family:Courier'>tottenham_court_road</span><span lang=EN-US>, </span><span
lang=EN-US style='font-family:Courier'>leicester_square</span><span lang=EN-US>,
and </span><span lang=EN-US style='font-family:Courier'>noroute</span><span
lang=EN-US> as leaves (fig. 1.6). Conversely, trees can be represented by
Prolog terms. </span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;tree:represented by a term&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
4.1</span></i><span lang=EN-US>. Draw the tree represented by the term </span><span
lang=EN-US style='font-family:Courier'>1(2(4),3(5,6))</span><span lang=EN-US>.</span></p>

</div>

<p class=sektie><span lang=EN-US>A tree is traversed by first visiting its root</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;root
of a tree&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, and then recursively traversing all of its subtree</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;subtree&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s. A list of subtrees is obtained by decomposing the complex term</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;complex
term&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>by means of the </span><span
lang=EN-US style='font-family:Courier'>=..</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;=../2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>predicate (see section
3.7): </span></p>

<pre class="source swish temp" data-variant-id="group-4" id="swish.4.1.1" style="display: block;">
% term_tree(T,R,S) &lt;- term T represents a tree with root R and list of subtrees S
term_tree(Tree,Root,Subtrees):-
Tree=..[Root|Subtrees].

% term_root(T,R) &lt;- R is the root of tree T
term_root(Tree,Root):-
term_tree(Tree,Root,S).

% term_subtree(T,S) &lt;- S is a subtree of tree T
term_subtree(Tree,Subtree):-
term_tree(Tree,R,S),
member(Subtree,S).
</pre>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .25pt;padding:14.0pt 14.0pt 14.0pt 14.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto;
  margin-left:1.0cm;margin-right:1.0cm'>
  <p class=inter-title style='margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>Data abstraction</span><!--[if supportFields]><span
  lang=EN-US><span style='mso-element:field-begin'></span> XE<span
  style="mso-spacerun:yes">&nbsp; </span>&quot;Data abstraction&quot; </span><![endif]--><!--[if supportFields]><span
  lang=EN-US><span style='mso-element:field-end'></span></span><![endif]--></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>The principle of <i style='mso-bidi-font-style:
  normal'>data abstraction</i> prescribes to keep datastructures local to
  specific predicates such as </span><span lang=EN-US style='font-family:Courier'>term_tree</span><span
  lang=EN-US>, </span><span lang=EN-US style='font-family:Courier'>term_root</span><span
  lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>term_subtree</span><span
  lang=EN-US>, and to access the datastructures only through these predicates.
  The main advantage of this design principle is <i style='mso-bidi-font-style:
  normal'>modularity</i>: if we choose to change the representation of a tree,
  we just have to modify these specific predicates, but the predicates which
  call them need not be changed. In contrast, if we unfold</span><!--[if supportFields]><span
  lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
  XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;unfolding&quot;
  </span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:
  none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
  lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span></span><span
  lang=EN-US style='font-family:Courier'>term_tree</span><span lang=EN-US>, </span><span
  lang=EN-US style='font-family:Courier'>term_root</span><span lang=EN-US> and </span><span
  lang=EN-US style='font-family:Courier'>term_subtree</span><span lang=EN-US>
  into the definition of </span><span lang=EN-US style='font-family:Courier'>term_arc</span><span
  lang=EN-US>, <br>
  we get the following piece of code:</span></p>
  <p class=intermezzo align=left style='margin-top:0cm;margin-right:0cm;
  margin-bottom:0cm;margin-left:114.65pt;margin-bottom:.0001pt;text-align:left;
  text-indent:-114.65pt;tab-stops:113.0pt;background:#E5E5E5;mso-shading:windowtext;
  mso-pattern:gray-10 auto'><span lang=EN-US style='font-family:Courier'><span
  style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>term_arc(Tree,[Root,R]):-<br>
  Tree=..[Root|Subtrees].<br>
  element(Subtree,Subtrees),<br>
  Subtree=..[R|S].<o:p></o:p></span></p>
  <p class=intermezzo align=left style='margin-top:0cm;margin-right:0cm;
  margin-bottom:6.0pt;margin-left:114.65pt;text-align:left;text-indent:-114.65pt;
  tab-stops:113.0pt;background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto'><span
  lang=EN-US style='font-family:Courier'><span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>term_arc(Tree,Arc):-<br>
  Tree=..[Root|Subtrees].<br>
  element(Subtree,Subtrees),<br>
  term_arc(Subtree,Arc).<o:p></o:p></span></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>This program fragment is badly designed,
  because </span><span lang=EN-US style='font-family:Courier'>term_arc</span><span
  lang=EN-US> explicitly mentions the way trees are represented by Prolog
  terms. Consequently, if we change this representation, </span><span
  lang=EN-US style='font-family:Courier'>term_arc</span><span lang=EN-US> needs
  to be changed as well. This illustrates that the design of good datastructures
  is as important in Prolog <br>
  as it is in any other programming language. </span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=tekst><span lang=EN-US>By means of these simple predicates, we can
write a program for finding arcs and paths in a tree. Paths are represented as
lists of nodes, and an arc</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;arc&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is simply a path</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;path
in a graph&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>consisting of two nodes:
</span></p>

<pre class="source swish inherit" data-variant-id="group-4" inherit-id="swish.4.1.1" id="swish.4.1.2" style="display: block;">
% term_arc(T,A) &lt;- T is a tree, and A is an arc in T
term_arc(Tree,[Root,SR]):- % Arc from Root to Subtree
term_root(Tree,Root),
term_subtree(Tree,Subtree),
term_root(Subtree,SR).

term_arc(Tree,Arc):- % Arc in Subtree
term_subtree(Tree,Subtree),
term_arc(Subtree,Arc).

% term_path(T,P) &lt;- T is a tree, and P is a path in T
term_path(Tree,Arc):- % consisting of one arc
term_arc(Tree,Arc).

term_path(Tree,[Node1,Node2|Nodes]):- % several arcs 
term_arc(Tree,[Node1,Node2]),
term_path(Tree,[Node2|Nodes]).
</pre>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
4.2</span></i><span lang=EN-US>. Give a term </span><span lang=EN-US
style='font-family:Courier'>Tree</span><span lang=EN-US>, such that it contains
the tree of exercise 4.1, and such that </span><span lang=EN-US
style='font-family:Courier'>Path=[1,2,7,8]</span><span lang=EN-US> is an answer
to the query <br>
<span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>?-term_path(Tree,Path)</span><span
lang=EN-US>.</span></p>

</div>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=small-figure style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm'><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
   id="Picture_x0020_5" o:spid="_x0000_i1031" type="#_x0000_t75" style='width:174pt;
   height:96pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20II_files/image007.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=176 height=98
  src="Part%20II_files/image008.png" v:shapes="Picture_x0020_5"><![endif]></span></p>
  </div>
  <p class=small-caption><b style='mso-bidi-font-weight:normal'><span
  lang=EN-US>Figure 4.2.</span></b><span lang=EN-US> Which are the paths <br>
  through this tree?</span></p>
  </td>
 </tr>
</table>

</div>

<p class=sektie style='page-break-after:avoid'><span lang=EN-US>Consider the
tree in fig. 4.2. The following query lists all the paths in this tree:</span></p>

<pre class="query" id="query.4.1.1"><span class="swish query">?-term_path(n1(n2(n4,n5(n7),n6),n3(n8,n9(n10))),Path).</span></pre>
<p class=query style='margin-bottom:6.0pt;mso-pagination:widow-orphan;
page-break-after:auto'><span lang=EN-US>
Path = [1,2];<br>
Path = [1,3];<br>
Path = [2,4];<br>
Path = [2,5];<br>
Path = [2,6];<br>
Path = [5,7];<br>
Path = [3,8];<br>
Path = [3,9];<br>
Path = [9,10];<br>
Path = [1,2,4];<br>
Path = [1,2,5];<br>
Path = [1,2,6];<br>
Path = [1,2,5,7];<br>
Path = [1,3,8];<br>
Path = [1,3,9];<br>
Path = [1,3,9,10];<br>
Path = [2,5,7];<br>
Path = [3,9,10];<br>
No more solutions</span></p>

<p class=MsoNormal style='page-break-after:avoid'><span lang=EN-US><o:p>&nbsp;</o:p></span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-element-anchor-horizontal:
column;mso-element-left:center;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:0cm;margin-right:0cm;margin-bottom:18.0pt;
  margin-left:0cm;mso-element:frame;mso-element-wrap:auto;mso-element-anchor-horizontal:
  column;mso-element-left:center;mso-height-rule:exactly'><i style='mso-bidi-font-style:
  normal'><span lang=EN-US>Exercise 4.3</span></i><span lang=EN-US>. Explain
  the order in which these paths are found. </span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>It would be convenient to have a program for
printing Prolog terms which represent trees in a tree-like way. The nicest way
to do this is to print from the root down; however, this requires a rather
elaborate program</span><a style='mso-footnote-id:ftn2' href="#_ftn2"
name="_ftnref2" title=""><span class=MsoFootnoteReference><span lang=EN-US
style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span style='mso-special-character:
footnote'><![if !supportFootnotes]><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:Times;
mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA'>[13]</span></span><![endif]></span></span></span></a><span
lang=EN-US>. A reasonable alternative is to print the tree rotated at 90
degrees, from the root to the right. A program to do this is given below.</span></p>

<pre class="source swish inherit" data-variant-id="group-4" inherit-id="swish.4.1.1" id="swish.4.1.3" query-text="?- term_write(n1(n2(n4,n5(n7),n6),n3(n8,n9(n10))))." style="display: block;">
term_write(Tree):-
  term_write(0,Tree),nl.

% write a Tree at position Pos
term_write(Pos,Tree):-
  term_tree(Tree,Root,Subtrees),  % decompose Tree
  term_write_node(Pos,Pos2,Root), % write Root
  term_writes(Pos2,Subtrees).     % new position

% write a list of trees at position Pos
term_writes(Pos,[]).
term_writes(Pos,[Tree]):-!,       % no newline here
  term_write(Pos,Tree).
term_writes(Pos,[Tree|Subtrees]):-
  term_write(Pos,Tree),
  nl,tab(Pos),                    % skip to position Pos
  term_writes(Pos,Subtrees).

% write a Node from Begin to End
term_write_node(Begin,End,Node):-
  name(Node,L),length(L,N),       % N is length of Nodename
  End is Begin+10,
  N1 is End-Begin-N,              % N1 is length of line
  write_line(N1),
  write(Node).

% write a line of given length
write_line(0).
write_line(N):-
  N&gt;0,N1 is N-1,
  write('-'),
  write_line(N1).
</pre>

<p class=tekst><span lang=EN-US style='font-family:Courier'>name/2</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;name/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><a
style='mso-footnote-id:ftn3' href="#_ftn3" name="_ftnref3" title=""><span
class=MsoFootnoteReference><span lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:
10.0pt'><span style='mso-special-character:footnote'><![if !supportFootnotes]><span
class=MsoFootnoteReference><span lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:
Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:
AR-SA'>[14]</span></span><![endif]></span></span></span></a><span lang=EN-US>
is a built-in predicate, converting an atom into a list of ASCII-codes. In
combination with </span><span lang=EN-US style='font-family:Courier'>length/2</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;length/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, it is used to determine the number of characters in an atom. The
query </span><span lang=EN-US style='font-family:Courier'>?-term_write(1(2(4,5(7),6),3(8,9(10))))</span><span
lang=EN-US> displays the tree as follows:</span></p>

<p class=p-el><span lang=EN-US>---------1---------2---------4<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>---------5---------7<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>---------6<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>---------3---------8<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>---------9--------10</span></p>

<h3><span lang=EN-US>4.2<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Graphs
generated by a predicate</span></h3>

<p class=sektie1><span lang=EN-US>In the preceding section, a tree was
represented by a Prolog term. This is convenient for relatively small trees
such as proof tree</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;proof
tree&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s, that are processed and passed around as a unit. However, for
bigger trees it is a better idea not to represent them explicitly by a Prolog
term, but implicitly by a set of ground facts, listing the arcs in the graph.
An additional advantage of this representation is the possibility of
representing graphs that are not trees. </span></p>

<p class=sektie><span lang=EN-US>As an example of this representation, the tree
in fig. 4.2 would be represented by the following facts:</span></p>

<p class=p-el style='mso-pagination:widow-orphan'><span lang=EN-US>arc(1,2).<br>
arc(1,3).<br>
arc(2,4).<br>
arc(2,5).<br>
arc(2,6).<br>
arc(5,7).<br>
arc(3,8).<br>
arc(3,9).<br>
arc(9,10).</span></p>

<p class=tekst><span lang=EN-US>The predicate for finding a path in a graph now
needs a few minor adjustments: the graph is not passed on as an argument, and </span><span
lang=EN-US style='font-family:Courier'>arc/2</span><span lang=EN-US> is used
rather than </span><span lang=EN-US style='font-family:Courier'>term_arc/2</span><span
lang=EN-US>:</span></p>

<pre class="source swish" data-variant-id="group-4" id="swish.4.2.1" query-text="?- path([n1,Node2])." style="display: block;"
source-text-start=
"arc(n1,n2).
arc(n1,n3).
arc(n2,n4).
arc(n2,n5).
arc(n2,n6).
arc(n5,n7).
arc(n3,n8).
arc(n3,n9).
arc(n9,n10).
">
% path(P) &lt;- P is a path in the graph given by arc/2
path([Node1,Node2]):-
  arc(Node1,Node2).
path([Node1,Node2|Nodes]):-
  arc(Node1,Node2),
  path([Node2|Nodes]).
</pre>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
4.4</span></i><span lang=EN-US>. Draw the SLD-tree for the query </span><span
lang=EN-US style='font-family:Courier'>?-path([1|Path])</span><span lang=EN-US>.</span></p>

</div>

<p class=sektie><span lang=EN-US style='font-family:Courier'>path/2</span><span
lang=EN-US> will generate paths between any two connected nodes. When searching
a graph such as an SLD-tree, we are normally only interested in paths which
start at a given node (for instance, the root of a tree), and end in a leaf.
The following program will do the job. Note that this program differs from the
previous one in that it allows for paths consisting of one node only.</span></p>

<pre class="source swish" data-variant-id="group-4" id="swish.4.2.2" query-text="?- path_leaf(1,Path)." style="display: block;"
source-text-start=
"arc(n1,n2).
arc(n1,n3).
arc(n2,n4).
arc(n2,n5).
arc(n2,n6).
arc(n5,n7).
arc(n3,n8).
arc(n3,n9).
arc(n9,n10).

">
% path_leaf(N,P) &lt;- P is a path starting at node N, ending 
%                      in a leaf in the graph given by arc/2
path_leaf(Leaf,[Leaf]):-
  leaf(Leaf).
path_leaf(Node1,[Node1|Nodes]):-
  arc(Node1,Node2),
  path_leaf(Node2,Nodes).

leaf(Leaf):-
not arc(Leaf,SomeNode).
</pre>

<p class=tekst><span lang=EN-US>The query </span><span lang=EN-US
style='font-family:Courier'>?-path_leaf(1,Path)</span><span lang=EN-US> will
lead to the following answers:</span><span lang=EN-US style='font-family:Courier'><o:p></o:p></span></p>

<p class=p-el><span lang=EN-US>Path = [1,2,4];<br>
Path = [1,2,5,7];<br>
Path = [1,2,6];<br>
Path = [1,3,8];<br>
Path = [1,3,9,10];<br>
No more solutions</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
4.5</span></i><span lang=EN-US>. Draw the SLD-tree for this query.</span></p>

</div>

<p class=sektie><span lang=EN-US>Notice the order in which the paths to the
leafs are found &#8212; the longer path </span><span lang=EN-US
style='font-family:Courier'>[1,2,5,7]</span><span lang=EN-US> is found before
the shorter path </span><span lang=EN-US style='font-family:Courier'>[1,2,6]</span><span
lang=EN-US>. This kind of search is called <i style='mso-bidi-font-style:normal'>depth-first
search</i></span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;depth-first search&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, because the deepest unvisited nodes are preferred. In contrast, <i
style='mso-bidi-font-style:normal'>breadth-first search</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;breadth-first search&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>tries all nodes on a
given level before going one level deeper; consequently, shortest paths are
found first. Of course, the order in which nodes are visited can only be
understood procedurally &#8212; logically speaking, there is nothing in the
program which prescribes such an order. It is only because Prolog itself searches
the SLD-tree in a depth-first fashion, that programs like the above perform
depth-first search.</span></p>

<p class=sektie1><span lang=EN-US>In real life, graphs are often infinite. For
instance, many SLD-trees are infinite, even for very simple programs such as
(br abbreviates brother):</span></p>

<p class=p-el><span lang=EN-US>br(X,Y):-br(X,Z),br(Z,Y).<br>
br(paul,peter).</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
4.6</span></i><span lang=EN-US>. Sketch the SLD-tree for the query </span><span
lang=EN-US style='font-family:Courier'>?-br(paul,B)</span><span lang=EN-US>.</span></p>

</div>

<p class=tekst><span lang=EN-US>SLD-tree</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;SLD-tree&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s are graphs, with resolvents as nodes. Representing a resolvent by
the list of its literals, we would need an infinite number of facts to
represent SLD-trees, for instance:</span></p>

<p class=p-el><span lang=EN-US>arc([br(paul,B)],[br(paul,Z),br(Z,B)]).<br>
arc([br(paul,B)],[]).<br>
arc([br(paul,Z),br(Z,B)],[br(paul,Z1),br(Z1,Z),br(Z,B)]).<br>
arc([br(paul,Z),br(Z,B)],[br(peter,B)]).<br>
arc([br(paul,Z),br(Z,B)],[br(paul,paul)]).<br>
...<br>
arc([br(peter,B)],[br(peter,Z),br(Z,B)]).<br>
...<br>
arc([br(paul)],[br(paul,Z),br(Z,paul)]).<br>
...</span></p>

<p class=tekst><span lang=EN-US>In such cases, it is a better idea to write a
program which <b style='mso-bidi-font-weight:normal'>generates</b> these facts.
In other words, we need a logical definition of </span><span lang=EN-US
style='font-family:Courier'>arc/2</span><span lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>Now, </span><span lang=EN-US style='font-family:
Courier'>arc(A,B)</span><span lang=EN-US> is true if </span><span lang=EN-US
style='font-family:Courier'>A</span><span lang=EN-US> and </span><span
lang=EN-US style='font-family:Courier'>B</span><span lang=EN-US> are lists of
negative literals interpreted as resolvents, and one resolution step applied to
</span><span lang=EN-US style='font-family:Courier'>A</span><span lang=EN-US>
and a clause for </span><span lang=EN-US style='font-family:Courier'>br/2</span><span
lang=EN-US> yields </span><span lang=EN-US style='font-family:Courier'>B</span><span
lang=EN-US>. We can write this down by means of the predicate </span><span
lang=EN-US style='font-family:Courier'>resolve/3</span><span lang=EN-US>, which
performs one resolution step, and the two clauses for </span><span lang=EN-US
style='font-family:Courier'>br/2</span><span lang=EN-US> in the appropriate
representation. This gives the following program:</span></p>

<pre class="source swish" data-variant-id="group-4" id="swish.4.2.3" query-text="?- arc([br(paul,B)],N)." style="display: block;">
arc(A,B):- resolve(A,(br(X,Y):-[br(X,Z),br(Z,Y)]),B).
arc(A,B):- resolve(A,(br(paul,peter):-[]),B).

% resolve(G,C,NewG) &lt;- the goal G (a list of atoms)
%                          resolves with the clause C (body
%                          is a list) to yield the goal NewG
resolve([H1|T],(H2:-Body),B):-
  H1=H2,    % literal in goal unifies with head of clause
  append(Body,T,B).
resolve([H|T],Clause,[H|B]):-
  resolve(T,Clause,B).  % try next literal
</pre>

<p class=MsoNormal><span lang=EN-US>The query </span><span lang=EN-US
style='font-family:Courier'>?-arc([br(paul,B)],N)</span><span lang=EN-US>
results in the answers</span></p>

<p class=p-el><span lang=EN-US>B = Y<br>
N = [br(paul,Z),br(Z,Y)];</span></p>

<p class=p-laatst><span lang=EN-US>B = peter<br>
N = []</span></p>

<p class=tekst><span lang=EN-US>as expected.</span></p>

<p class=sektie><span lang=EN-US>Note that a query of the form </span><span
lang=EN-US style='font-family:Courier'>?-arc(R,[])</span><span lang=EN-US> asks
for a path from </span><span lang=EN-US style='font-family:Courier'>R</span><span
lang=EN-US> to a success branch in the SLD-tree, thus simulating a query </span><span
lang=EN-US style='font-family:Courier'>:-R</span><span lang=EN-US>. That is,
the above program for </span><span lang=EN-US style='font-family:Courier'>arc/2</span><span
lang=EN-US> is simply a meta-interpreter (with the object-level program
hardwired in its clauses). In section 5.3, we encounter a similar
meta-interpreter for full clausal logic.</span></p>

<h3><span lang=EN-US>4.3<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Inheritance
hierarchies</span></h3>

<p class=sektie1><span lang=EN-US>In the foregoing sections, we studied two
kinds of graphs: trees represented by Prolog terms, and graphs generated by
predicate definitions. In both cases, the main inference step is to search for
a path satisfying certain conditions. In this section, we study a type of
structured knowledge called an <i style='mso-bidi-font-style:normal'>inheritance
hierarchy</i></span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;inheritance hierarchy&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, which differs from the previous cases in that it requires a more
elaborate kind of reasoning. Basically, this is because a node in such a
hierarchy is a more complex entity with various kinds of properties. Lower
nodes in the hierarchy <i style='mso-bidi-font-style:normal'>inherit</i>
properties from ancestor nodes, unless they are assigned a property of their
own. Thus, reasoning about inheritance hierarchies not only requires searching
for a path, but also collecting properties found along a path. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm'>
  <p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
   id="Picture_x0020_6" o:spid="_x0000_i1030" type="#_x0000_t75" style='width:321pt;
   height:2in;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20II_files/image009.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=323 height=146
  src="Part%20II_files/image010.png" v:shapes="Picture_x0020_6"><![endif]></span></p>
  </div>
  <p class=Caption1><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  4.3</span></b><span lang=EN-US>. An inheritance hierarchy of musical
  instruments. Nodes in the tree denote classes; at the bottom, instances for
  each class are listed. </span></p>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>Fig. 4.3 displays an inheritance hierarchy of
a variety of musical instruments. The topmost node represents the <i
style='mso-bidi-font-style:normal'>class</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;class&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of all instruments in
the Universe of Discourse</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Universe
of Discourse&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, which has three <i style='mso-bidi-font-style:normal'>subclass</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;subclass&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>es</span></i><span
lang=EN-US>: wind instruments, string instruments, and percussion instruments.
In turn, wind instruments are divided into woodwinds and brass instruments, and
so on. At the bottom of the figure, <i style='mso-bidi-font-style:normal'>instance</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;instance&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US> are listed for each most specific subclass. Thus, guitar, lute and
harp are instances of the class plucked instruments, and thus also of the
classes string instruments and instruments. </span></p>

<p class=sektie><span lang=EN-US>If we want to represent such hierarchies in
Prolog, we have to choose a representation for instances and classes. By far
the most natural choice is to represent an instance by a constant, and a class
by a unary predicate. A class&#8211;superclass relation is then expressed by a
clause, and an instance&#8211;class relation is expressed by a ground fact: </span></p>

<pre class="source swish temp" data-variant-id="group-4" id="swish.4.3.1" query-text="?- instrument(X)." style="display: block;">
% Classes
instrument(X):-wind(X).
instrument(X):-string(X).
instrument(X):-percussion(X).
wind(X):-woodwind(X).
wind(X):-brass(X).
string(X):-plucked(X).
string(X):-bowed(X).
string(X):-keyboard(X).
percussion(X):-tuned(X).
percussion(X):-untuned(X).

% Instances
woodwind(recorder).
woodwind(flute).
woodwind(oboe).
woodwind(saxophone).
brass(trumpet).
brass(trombone).
brass(horn).
plucked(guitar).
plucked(lute).
plucked(harp).
bowed(violin).
bowed(cello).
keyboard(harpsichord).
keyboard(piano).
tuned(triangle).
tuned(kettledrum).
untuned(cymbal).
untuned(snaredrum).
</pre>

<p class=tekst><span lang=EN-US>With these clauses, it is possible to ask
questions about instances and (super)classes. For example, we can find out what
instruments there are by means of the query </span></p>

<p class=p-el><span lang=EN-US>?&#8209;instrument(X).</span></p>

<p class=sektie><span lang=EN-US>As was remarked above, nodes (and instances)
in an inheritance hierarchy can be assigned properties, where a <i
style='mso-bidi-font-style:normal'>property</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;property&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is an
attribute&#8211;value pair. For instance, the material an instrument is made of
can be an attribute</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;attribute&quot;
\b </span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, with possible values wood and metal.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;value
of an attribute&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>The statement
saxophones are made of metal is represented by the ground fact </span></p>

<p class=p-el><span lang=EN-US>material(saxophone,metal)</span></p>

<p class=tekst><span lang=EN-US>The statement instances of the class of string
instruments are made of wood is represented by the clause</span></p>

<p class=pi-el><span lang=EN-US>material(X,wood):-string(X).</span></p>

<p class=tekst><span lang=EN-US>Since </span><span lang=EN-US style='font-family:
Courier'>string(piano)</span><span lang=EN-US> is a logical consequence of the
previous clauses expressing the hierarchy, we can now prove </span><span
lang=EN-US style='font-family:Courier'>material(piano,wood)</span><span
lang=EN-US>. Thus, the chosen representation takes care of the inheritance of
properties, as required. </span></p>

<p class=sektie><span lang=EN-US>In our musical Universe of Discourse</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Universe
of Discourse&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, we consider three attributes: the </span><span lang=EN-US
style='font-family:Courier'>function</span><span lang=EN-US> of an instrument
(all instruments have a musical function), the </span><span lang=EN-US
style='font-family:Courier'>material</span><span lang=EN-US> of an instrument
(wood or metal), and the way the instrument produces sound, expressed by the
attribute </span><span lang=EN-US style='font-family:Courier'>action</span><span
lang=EN-US>: </span></p>

<pre class="source swish inherit" data-variant-id="group-4" inherit-id="swish.4.3.1" id="swish.4.3.2" query-text="?- material(flute,M)." style="display: block;">
function(X,musical):-instrument(X).

% Materials
material(flute,metal).
material(saxophone,metal).
material(X,wood):-woodwind(X).
material(X,metal):-brass(X).
material(X,wood):-string(X).
material(X,metal):-percussion(X).

% Actions
action(oboe,reed(double)).
action(saxophone,reed(single)).
action(harpsichord,plucked).
action(piano,hammered).
action(X,reed(lip)):-brass(X).
action(X,plucked):-plucked(X).
action(X,bowed):-bowed(X).
action(X,hammered):-percussion(X).
</pre>

<p class=tekst><span lang=EN-US>For instance, all brass instruments have lip-reeds,
while some woodwinds have a double reed (oboes, for example) or a single reed
(saxophones). </span></p>

<p class=sektie><span lang=EN-US>Note that there is a potential conflict in the
above clauses: woodwinds are generally made of wood, but flutes and saxophones
are made of metal. Thus, the query </span></p>

<p class=p-el><span lang=EN-US>?-material(flute,M)</span></p>

<p class=tekst><span lang=EN-US>has two answers: </span></p>

<p class=p-el><span lang=EN-US>M = metal;<br>
M = wood</span></p>

<p class=tekst><span lang=EN-US>The order in which these answers are found is,
of course, determined by the order of the clauses above. Since we put the
ground facts listing properties of instances before the clauses listing
properties assigned to classes (and the clauses pertaining to classes before
those pertaining to superclasses), the answers are found by climbing the
inheritance hierarchy from bottom to top, and the first property found is the
desired one. It should be noted, however, that things are not always that
simple. If more sophisticated <i style='mso-bidi-font-style:normal'>inheritance</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;inheritance</span></i><span
lang=EN-US> strategy<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>strategies</span></i><span lang=EN-US>
are needed, alternative representations, like the ones to be discussed later in
this section, are to be preferred. </span></p>

<p class=sektie><span lang=EN-US>A typical thing one would like to know
regarding an inheritance hierarchy is: what are the properties of a given
instance? In principle, this requires a second-order query</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;second-order
query&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span></span></p>

<p class=p-el><span lang=EN-US>?-Attr(Inst,Value)</span></p>

<p class=tekst><span lang=EN-US>which is not allowed in Prolog if </span><span
lang=EN-US style='font-family:Courier'>Attr</span><span lang=EN-US> is not
instantiated. We can get around this by maintaining a list of all attributes,
and constructing the appropriate goal for each attribute by means of the
predicate </span><span lang=EN-US style='font-family:Courier'>get_value/3</span><span
lang=EN-US>: </span></p>

<pre class="source swish inherit" data-variant-id="group-4" inherit-id="swish.4.3.1 swish.4.3.2" id="swish.4.3.3" query-text="?- properties(saxophone,P)." style="display: block;">
properties(Inst,Props):-
  attributes(Attrs),
  properties(Attrs,Inst,Props).
properties([],Inst,[]).
properties([Attr|Attrs],Inst,[Attr=Value|Props]):-
  get_value(Attr,Inst,Value),!,   % only first answer
  properties(Attrs,Inst,Props).

attributes([function,material,action]).

get_value(A,B,C):-
  Goal =.. [A,B,C],
  call(Goal).
</pre>

<p class=tekst style='page-break-after:avoid'><span lang=EN-US>For instance,
the query </span><span lang=EN-US style='font-family:Courier'>?-properties(saxophone,P)</span><span
lang=EN-US> yields the answer </span></p>

<p class=p-el><span lang=EN-US>P =
[function=musical,material=metal,action=reed(single)]</span></p>

<p class=tekst><span lang=EN-US>Only the most specific property regarding
material is found, because of the cut in the recursive clause of </span><span
lang=EN-US style='font-family:Courier'>properties/3</span><span lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>As indicated above, the representation of
inheritance hierarchies by means of clauses only allows a relatively simple
inheritance strategy. Moreover, since classes are represented by predicates,
reasoning about classes becomes a second-order logical inference. For example,
the question what are the subclasses of the class of instruments is not
easily handled in the above representation. Both shortcomings can be alleviated
if classes and attributes are represented by terms instead of predicates. In
effect, this will result in a clearer separation of declarative knowledge
describing the hierarchy, and procedural knowledge describing the inheritance
strategy. This can be done in several ways; two possibilities are worked out
below. </span></p>

<p class=sektie1><span lang=EN-US>The first idea is to represent the tree in
fig. 4.3 according to the first method in section 4.2, i.e. by a set of ground
facts listing the arcs in the tree. Thus, nodes (classes) are represented by
constants, and arcs (class&#8211;superclass relations) are represented by means
of the predicate </span><span lang=EN-US style='font-family:Courier'>isa/2</span><span
lang=EN-US>: </span></p>

<p class=oms-eerst><span lang=EN-US>% Classes</span></p>

<p class=programma style='page-break-after:auto;tab-stops:197.0pt'><span
lang=EN-US>isa(wind,instrument).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>isa(string,instrument).</span></p>

<p class=programma style='page-break-after:auto;tab-stops:197.0pt'><span
lang=EN-US>isa(percussion,instrument).<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>isa(woodwind,wind).</span></p>

<p class=programma style='page-break-after:auto;tab-stops:197.0pt'><span
lang=EN-US>isa(brass,wind).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>isa(plucked,string).</span></p>

<p class=programma style='tab-stops:197.0pt'><span lang=EN-US>isa(bowed,string).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>isa(keyboard,string).</span></p>

<p class=p-laatst style='tab-stops:197.0pt'><span lang=EN-US>isa(tuned,percussion).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>isa(untuned,percussion).</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .25pt;padding:14.0pt 14.0pt 14.0pt 14.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto;
  margin-left:1.0cm;margin-right:1.0cm'>
  <p class=inter-title style='margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>Instance&#8211;class vs.
  class&#8211;superclass</span></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>In this representation there appears to be no
  difference between instance&#8211;class relations and class&#8211;superclass
  relations. Indeed, we could have treated instances just as classes, and use
  the </span><span lang=EN-US style='font-family:Courier'>isa/2</span><span
  lang=EN-US> predicate for both. However, this obscures the semantic difference
  between instances and classes, which can lead to problems. For example,
  instances of one class can be <i style='mso-bidi-font-style:normal'>composed</i>
  of instances of other classes (a bicycle is composed of two wheels and a
  frame), but this is not true for classes <br>
  (the class of bicycles is not composed of the class of wheels <br>
  and the class of frames). </span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=tekst><span lang=EN-US>Instances are listed by means of the predicate </span><span
lang=EN-US style='font-family:Courier'>inst/2</span><span lang=EN-US>: </span></p>

<p class=oms-eerst><span lang=EN-US>% Instances</span></p>

<p class=programma style='tab-stops:197.0pt'><span lang=EN-US>inst(recorder,woodwind).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inst(flute,woodwind).</span></p>

<p class=programma style='page-break-after:auto;tab-stops:197.0pt'><span
lang=EN-US>inst(oboe,woodwind).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inst(saxophone,woodwind).</span></p>

<p class=programma style='tab-stops:197.0pt'><span lang=EN-US>inst(trumpet,brass).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inst(trombone,brass).</span></p>

<p class=programma style='tab-stops:197.0pt'><span lang=EN-US>inst(horn,brass).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inst(guitar,plucked).</span></p>

<p class=programma style='page-break-after:auto;tab-stops:197.0pt'><span
lang=EN-US>inst(lute,plucked).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inst(harp,plucked).</span></p>

<p class=programma style='page-break-after:auto;tab-stops:197.0pt'><span
lang=EN-US>inst(violin,bowed).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inst(cello,bowed).</span></p>

<p class=programma style='page-break-after:auto;tab-stops:197.0pt'><span
lang=EN-US>inst(harpsichord,keyboard).<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>inst(piano,keyboard).</span></p>

<p class=programma style='tab-stops:197.0pt'><span lang=EN-US>inst(triangle,tuned).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inst(kettledrum,tuned).</span></p>

<p class=p-laatst style='tab-stops:197.0pt'><span lang=EN-US>inst(cymbal,untuned).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inst(snaredrum,untuned).</span></p>

<p class=sektie><span lang=EN-US>The difference between inheritance</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;inheritance
hierarchy&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>hierarchies and ordinary
graphs lies in the additional meaning assigned to classes and instances by
means of properties. Therefore, a graph extended with properties is commonly
called a <i style='mso-bidi-font-style:normal'>semantic network</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;semantic network&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Properties are represented by means of the predicate </span><span
lang=EN-US style='font-family:Courier'>prop/3</span><span lang=EN-US>: </span></p>

<p class=oms-eerst><span lang=EN-US>% Class properties</span></p>

<p class=programma><span lang=EN-US>prop(instrument,function,musical).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>prop(string,material,wood).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>prop(percussion,material,metal).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>prop(percussion,action,hammered).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>prop(woodwind,material,wood).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>prop(brass,material,metal).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>prop(brass,action,reed(lip)).</span></p>

<p class=programma><span lang=EN-US>prop(plucked,action,plucked).</span></p>

<p class=p-laatst><span lang=EN-US>prop(bowed,action,bowed).</span></p>

<p class=oms><span lang=EN-US>% Instance properties</span></p>

<p class=programma><span lang=EN-US>prop(flute,material,metal).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>prop(oboe,action,reed(double)).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>prop(saxophone,material,metal).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>prop(saxophone,action,reed(single)).</span></p>

<p class=programma><span lang=EN-US>prop(harpsichord,action,plucked).</span></p>

<p class=p-laatst><span lang=EN-US>prop(piano,action,hammered).</span></p>

<p class=tekst><span lang=EN-US>Since we will be using a more sophisticated
inheritance strategy, the order of these facts is now immaterial. </span></p>

<p class=sektie><span lang=EN-US>The inheritance strategy is to collect the
properties of instances before properties inherited from classes: </span></p>

<p class=pi-el style='tab-stops:198.0pt 256.0pt'><span lang=EN-US>properties_sn</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;properties_sn/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Inst,Props):-<br>
props(Inst,InstProps),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>%
properties of instance<br>
inst(Inst,Class),<br>
inherit_sn(Class,InstProps,Props).<span style='mso-tab-count:1'> </span>%
inherit the rest</span></p>

<p class=pi-laatst><span lang=EN-US>props(IC,Props):-<br>
findall(Attr=Value,prop(IC,Attr,Value),Props).</span></p>

<p class=tekst><span lang=EN-US>In turn, inherited properties are collected
from bottom to top in the hierarchy, so that specific properties are found
before general properties: </span></p>

<p class=pi-eerst><span lang=EN-US>inherit_sn</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;inherit_sn/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(top,Props,Props).</span></p>

<p class=pi-laatst style='tab-stops:208.0pt 256.0pt'><span lang=EN-US>inherit_sn(Class,SpecificProps,AllProps):-<br>
props(Class,GeneralProps),<span style='mso-tab-count:1'> </span>% properties of
this class<br>
override(SpecificProps,GeneralProps,Props),<br>
isa(Class,SuperClass),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>%
climb hierarchy<br>
inherit_sn(SuperClass,Props,AllProps).<span style='mso-tab-count:1'> </span>%
inherit rest</span></p>

<p class=tekst><span lang=EN-US style='font-family:Courier'>top</span><span
lang=EN-US> refers to the root of the universal inheritance hierarchy, which
should be added as the root of any sub-hierarchy:</span></p>

<p class=p-el><span lang=EN-US>isa(instrument,top).</span></p>

<p class=sektie><span lang=EN-US>The predicate </span><span lang=EN-US
style='font-family:Courier'>override/3</span><span lang=EN-US> checks for every
general property whether a more specific property has already been found. If
so, we say that the specific property <i style='mso-bidi-font-style:normal'>overrides</i>
the general property: </span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;overriding&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<pre class="source swish" data-variant-id="group-4" id="swish.4.3.4" query-text="?- properties_sn(saxophone,P)." style="display: block;"
source-text-start=
"% Classes
isa(instrument,top).
isa(wind,instrument).
isa(string,instrument).
isa(percussion,instrument).
isa(woodwind,wind).
isa(brass,wind).
isa(plucked,string).
isa(bowed,string).
isa(keyboard,string).
isa(tuned,percussion).
isa(untuned,percussion).

% Instances
inst(recorder,woodwind).
inst(flute,woodwind).
inst(oboe,woodwind).
inst(saxophone,woodwind).
inst(trumpet,brass).
inst(trombone,brass).
inst(horn,brass).
inst(guitar,plucked).
inst(lute,plucked).
inst(harp,plucked).
inst(violin,bowed).
inst(cello,bowed).
inst(harpsichord,keyboard).
inst(piano,keyboard).
inst(triangle,tuned).
inst(kettledrum,tuned).
inst(cymbal,untuned).
inst(snaredrum,untuned).

% Class properties
prop(instrument,function,musical).
prop(string,material,wood).
prop(percussion,material,metal).
prop(percussion,action,hammered).
prop(woodwind,material,wood).
prop(brass,material,metal).
prop(brass,action,reed(lip)).
prop(plucked,action,plucked).
prop(bowed,action,bowed).

% Instance properties
prop(flute,material,metal).
prop(oboe,action,reed(double)).
prop(saxophone,material,metal).
prop(saxophone,action,reed(single)).
prop(harpsichord,action,plucked).
prop(piano,action,hammered).


properties_sn(Inst,Props):-
  props(Inst,InstProps),    % properties of instance
  inst(Inst,Class),
  inherit_sn(Class,InstProps,Props). % inherit the rest

props(IC,Props):-
  findall(Attr=Value,prop(IC,Attr,Value),Props).

inherit_sn(top,Props,Props).
inherit_sn(Class,SpecificProps,AllProps):-
  props(Class,GeneralProps), % properties of this class
  override(SpecificProps,GeneralProps,Props),
  isa(Class,SuperClass),     % climb hierarchy
  inherit_sn(SuperClass,Props,AllProps). % inherit rest

">
override(Props,[],Props).
override(Specific,[Attr=Val|General],Props):-
  member(Attr=V,Specific),       % overriding
  override(Specific,General,Props).
override(Specific,[Attr=Val|General],[Attr=Val|Props]):-
  not member(Attr=V,Specific),   % no overriding
  override(Specific,General,Props).
</pre>

<p class=tekst><span lang=EN-US>Again, the query </span><span lang=EN-US
style='font-family:Courier'>?-properties_sn(saxophone,P)</span><span
lang=EN-US> yields the answer </span></p>

<p class=p-el><span lang=EN-US>P = [function=musical,material=metal,action=reed(single)]</span></p>

<p class=tekst><span lang=EN-US>What we gained with this representation,
however, is a declarative specification of the inheritance strategy, which is
therefore also amenable to change. For instance, if the inheritance hierarchy
is not a tree, a class could be a subclass of two or more other classes. In
this case, different values for the same attribute could be inherited along
different paths; this is called <i style='mso-bidi-font-style:normal'>multiple
inheritance</i></span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;multiple inheritance&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Such conflicts need to be resolved (or at least signalled) by the
inheritance strategy. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
4.7</span></i><span lang=EN-US>. Implement a multiple inheritance strategy. </span></p>

</div>

<p class=sektie1><span lang=EN-US>A slightly different but related
representation is obtained if we group all information about one class or
instance together in a socalled <i style='mso-bidi-font-style:normal'>frame</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;frame&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. A frame representation is obtained from the semantic network
representation by adding a list of properties to each arc in the network.
Below, class frames are defined by the predicate </span><span lang=EN-US
style='font-family:Courier'>class/3</span><span lang=EN-US>, and instance
frames are defined by the predicate </span><span lang=EN-US style='font-family:
Courier'>instance/3</span><span lang=EN-US>: </span></p>

<p class=oms-eerst><span lang=EN-US>% Classes</span></p>

<p class=programma><span lang=EN-US>class(instrument,top,[]).</span></p>

<p class=programma><span lang=EN-US>class(wind,instrument,[function=musical]).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>class(string,instrument,[material=wood]).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>class(percussion,instrument,[material=metal,<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>action=hammered]).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>class(woodwind,wind,[material=wood]).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>class(brass,wind,[material=metal,action=reed(lip)]).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>class(plucked,string,[action=plucked]).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>class(bowed,string,[action=bowed]).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>class(keyboard,string,[]).</span></p>

<p class=programma><span lang=EN-US>class(tuned,percussion,[]).</span></p>

<p class=p-laatst><span lang=EN-US>class(untuned,percussion,[]).</span></p>

<p class=programma><span lang=EN-US>% Instances</span></p>

<p class=programma><span lang=EN-US>instance(recorder,woodwind,[]).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>instance(flute,woodwind,[material=metal]).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>instance(oboe,woodwind,[action=reed(double)]).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>instance(saxophone,woodwind,[material=metal,<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>action=reed(single)]).</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>/*
etcetera... */</span></p>

<p class=programma><span lang=EN-US>instance(cymbal,untuned,[]).</span></p>

<p class=p-laatst><span lang=EN-US>instance(snaredrum,untuned,[]).</span></p>

<p class=tekst><span lang=EN-US>Inheritance is as easily implemented as in the
semantic network representation: </span></p>

<pre class="source swish" data-variant-id="group-2" id="swish.4.3.5" query-text="?- properties_fr(saxophone,P)." style="display: block;"
source-text-start=
"% Classes
class(instrument,top,[]).
class(wind,instrument,[function=musical]).
class(string,instrument,[material=wood]).
class(percussion,instrument,[material=metal,action=hammered]).
class(woodwind,wind,[material=wood]).
class(brass,wind,[material=metal,action=reed(lip)]).
class(plucked,string,[action=plucked]).
class(bowed,string,[action=bowed]).
class(keyboard,string,[]).
class(tuned,percussion,[]).
class(untuned,percussion,[]).

% Instances
instance(recorder,woodwind,[]).
instance(flute,woodwind,[material=metal]).
instance(oboe,woodwind,[action=reed(double)]).
instance(saxophone,woodwind,[material=metal,action=reed(single)]).
instance(trumpet,brass,[]).
instance(trombone,brass,[]).
instance(horn,brass,[]).
instance(guitar,plucked,[]).
instance(lute,plucked,[]).
instance(harp,plucked,[]).
instance(violin,bowed,[]).
instance(cello,bowed,[]).
instance(harpsichord,keyboard,[action=plucked]).
instance(piano,keyboard,[action=hammered]).
instance(triangle,tuned,[]).
instance(kettledrum,tuned,[]).
instance(cymbal,untuned,[]).
instance(snaredrum,untuned,[]).

"

source-text-end=
"
override(Props,[],Props).
override(Specific,[Attr=Val|General],Props):-
  member(Attr=V,Specific),       % overriding
  override(Specific,General,Props).
override(Specific,[Attr=Val|General],[Attr=Val|Props]):-
  not member(Attr=V,Specific),   % no overriding
  override(Specific,General,Props).
">
properties_fr(Inst,Props):-
  instance(Inst,Class,InstProps),       % instance properties
  inherit_fr(Class,InstProps,Props).    % inherit the rest

inherit_fr(top,Props,Props).
inherit_fr(Class,SpecificProps,AllProps):-
  class(Class,SuperClass,GeneralProps),         % this class
  override(SpecificProps,GeneralProps,Props),
  inherit_fr(SuperClass,Props,AllProps).        % inherit rest
</pre>

<p class=tekst><span lang=EN-US>Historically, semantic network and frame-based
representations were proposed in quite different contexts. We see that their
representation in Prolog is very similar. </span></p>

<h3><span lang=EN-US>Further reading</span></h3>

<p class=sektie1><span lang=EN-US>An introduction to Knowledge Representation
can be found in (Ringland &amp; Duce, 1989). (Brachman &amp; Levesque, 1985) is
a collection of papers discussing various aspects of Knowledge Representation,
such as the difference between isa-links and instance-of-links in semantic
networks. Papers about inheritance hierarchies can be found in (Lenzerini <i
style='mso-bidi-font-style:normal'>et al.</i>, 1991). LOGIN is an extension of
Prolog in which inheritance is represented by terms rather than clauses
(At-Kaci &amp; Nasr, 1986). </span></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>H.
At-Kaci &amp; R. Nasr (</span><span lang=EN-US>1986)<span style='font-variant:
small-caps'>,</span> LOGIN: a logic programming language with built-in
inheritance, <i style='mso-bidi-font-style:normal'>Journal of Logic
Programming</i> <b style='mso-bidi-font-weight:normal'>1986</b>(3): 185-215.<span
style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;At-Kaci,
H.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Nasr,
R.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>R.J.
Brachman &amp; H.J. Levesque</span><span lang=EN-US> (eds)<span
style='font-variant:small-caps'> (</span>1985)<span style='font-variant:small-caps'>,</span>
<i style='mso-bidi-font-style:normal'>Readings in Knowledge Representation</i>,
Morgan Kaufmann.<span style='display:none;mso-hide:all'>.J.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Brachman,
R.J.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.J.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Levesque,
H.J.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>M.
Lenzerini, D. Nardi &amp; M. Simi</span><span lang=EN-US> (eds)<span
style='font-variant:small-caps'> (</span>1991)<span style='font-variant:small-caps'>,</span>
<i style='mso-bidi-font-style:normal'>Inheritance Hierarchies in Knowledge
Representation and Programming Languages</i>, John Wiley.<span
style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Lenzerini,
M.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Nardi,
D.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Simi,
M.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>G.A.
Ringland &amp; D.A. Duce</span><span lang=EN-US> (eds)<span style='font-variant:
small-caps'> (</span>1989)<span style='font-variant:small-caps'>,</span> <i
style='mso-bidi-font-style:normal'>Approaches to Knowledge Representation: an
Introduction</i>, Research Studies Press.<span style='display:none;mso-hide:
all'>.A.;</span></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Ringland,
G.A.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.A.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Duce,
D.A.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

</div>

<b style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-size:18.0pt;
mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA'><br clear=all style='page-break-before:right;
mso-break-type:section-break'>
</span></b>

<div class=WordSection3>

<p class=cijfer><span lang=EN-US>5</span></p>

<h2><span lang=EN-US>Searching graphs</span></h2>

<p class=sektie1><span lang=EN-US>As explained earlier, a <i style='mso-bidi-font-style:
normal'>search problem</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;search problem&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is defined by a <i
style='mso-bidi-font-style:normal'>search space</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;search space&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, which is a graph with one or more <i style='mso-bidi-font-style:
normal'>starting nodes</i> and one or more <i style='mso-bidi-font-style:normal'>goal
nodes</i>. Given a search space, a <i style='mso-bidi-font-style:normal'>solution</i>
is a path from a starting node to a goal node . A <i style='mso-bidi-font-style:
normal'>cost function</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;cost function&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span><i style='mso-bidi-font-style:
normal'>c</i> assigns a number to each arc from <i style='mso-bidi-font-style:
normal'>n</i></span><span lang=EN-US style='font-size:9.0pt;position:relative;
top:2.0pt;mso-text-raise:-2.0pt'>1</span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>to <i style='mso-bidi-font-style:normal'>n</i></span><span
lang=EN-US style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:
-2.0pt'>2</span><span lang=EN-US>, specifying the <i style='mso-bidi-font-style:
normal'>cost</i> of moving from <i style='mso-bidi-font-style:normal'>n</i></span><span
lang=EN-US style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:
-2.0pt'>1</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>to
<i style='mso-bidi-font-style:normal'>n</i></span><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>2</span><span
lang=EN-US>. The cost of a path is the sum of the costs of the arcs in the
path. Given a search space and a cost function, an <i style='mso-bidi-font-style:
normal'>optimal solution</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;optimal solution&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is a solution with
minimal cost. A trivial example of a cost function is <i style='mso-bidi-font-style:
normal'>c</i>(<i style='mso-bidi-font-style:normal'>a</i>)=1 for each arc <i
style='mso-bidi-font-style:normal'>a</i>, in which case the cost of a path
equals the length of the path, and an optimal solution is a shortest path. For
SLD proofs, such a cost function would measure the depth of the proof tree. </span></p>

<p class=sektie><span lang=EN-US>In this chapter, we will discuss and implement
some basic techniques for finding solutions in search spaces. Their common
denominator is that they are <i style='mso-bidi-font-style:normal'>exhaustive</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;exhaustive</span></i><span
lang=EN-US> search<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: that is, in the worst case they will eventually visit every node
in the search space along every possible path, before finding a solution. On
the other hand, they differ with regard to: </span></p>

<p class=opsomming style='margin-left:28.0pt;text-indent:-10.15pt'><span
lang=EN-US><span style='mso-tab-count:1'>&nbsp; </span><i style='mso-bidi-font-style:
normal'>completeness</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;completeness</span></i><span
lang=EN-US>:of search strategies<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&#8212; will a solution
always be found?</span></p>

<p class=opsomming style='margin-left:28.0pt;text-indent:-10.15pt'><span
lang=EN-US><span style='mso-tab-count:1'>&nbsp; </span><i style='mso-bidi-font-style:
normal'>optimality</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;optimality</span></i><span
lang=EN-US>:of search strategies<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&#8212; will shorter
paths be found before longer ones?</span></p>

<p class=opsomming style='margin-left:28.0pt;text-indent:-10.15pt'><span
lang=EN-US><span style='mso-tab-count:1'>&nbsp; </span><i style='mso-bidi-font-style:
normal'>efficiency</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;efficiency</span></i><span
lang=EN-US> of search strategies<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&#8212; what are the
runtime and memory requirements?</span></p>

<p class=tekst><span lang=EN-US>We start with a general discussion of the
problem of search. Then, we will discuss the basic exhaustive search
strategies: depth-first search, breadth-first search, and forward chaining. </span></p>

<h3><span lang=EN-US>5.1<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>A
general search procedure</span></h3>

<p class=sektie1><span lang=EN-US>Imagine a visit with a friend to the
Staatsgalerie</span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Stuttgart
Staatsgalerie example&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>in Stuttgart. It is very
crowded in this beautiful art museum, and while admiring the <a name=bk0>Mondriaan<span
style='display:none;mso-hide:all'>.;</span> works you lose sight of each other.
Having been through situations like this before, you had made the agreement
that she would stay where she was, while you would go looking for her. What
strategy would you employ?</a></span></p>

<p class=sektie><span style='mso-bookmark:bk0'><span lang=EN-US>First of all,
to make sure that you dont miss any room, you have to visit them in some
systematic way. You dont have a global map of the building, so you decide to
never leave a room through the door through which you entered. Thinking about
it, you recognise that this procedure wont fully work, because a room might
have just one door: the one through which you entered. Assuming that there are
still rooms not yet visited, you <b style='mso-bidi-font-weight:normal'>have</b>
to leave such a room through the same door through which you entered, and find
a room youve visited before, with a door not yet taken. Such a procedure,
however, requires that, for each room you visit, you remember the door through
which you entered the room (in order to go back to a room youve been in
before), and the doors you tried already (in order to try a remaining door).</span></span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm'>
  <p class=figure><span style='mso-bookmark:bk0'><span lang=EN-US
  style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape id="Picture_x0020_7"
   o:spid="_x0000_i1029" type="#_x0000_t75" style='width:220pt;height:223pt;
   visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20II_files/image011.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=222 height=225
  src="Part%20II_files/image012.png" v:shapes="Picture_x0020_7"><![endif]></span></span></p>
  </div>
  <p class=Caption1><span style='mso-bookmark:bk0'><b style='mso-bidi-font-weight:
  normal'><span lang=EN-US>Figure 5.1.</span></b><span lang=EN-US> Searching
  for a friend.</span></span></p>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span style='mso-bookmark:bk0'><span lang=EN-US>Luckily enough,
you carry a piece of paper and a pencil with you, so you can stick little
papers saying entrance or exit on the appropriate doors. However, the
amount of paper you have is limited, so a better idea is to mark the doors <i
style='mso-bidi-font-style:normal'>not yet</i> tried, and to remove the paper
when you try a door, so that you can use the paper again. By reusing those
pieces of paper that become obsolete, you minimise the amount of paper needed.
Similarly, if you return to a room in which there are no remaining doors, you
will never return to that room, so you might want to remove the paper saying
entrance as well. On the other hand, leaving one paper might be a good idea,
just in case you return to the room later via a circular route; you are then
able to see that you already tried all the doors in that room.</span></span></p>

<p class=sektie><span style='mso-bookmark:bk0'><span lang=EN-US>So you decide
to employ the following procedure:</span></span></p>

<p class=opsomming style='margin-top:6.0pt;page-break-after:avoid'><span
style='mso-bookmark:bk0'><span lang=EN-US>1.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>mark
every door in the starting room as exit;</span></span></p>

<p class=opsomming><span style='mso-bookmark:bk0'><span lang=EN-US>2.<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>examine the current room;</span></span></p>

<p class=opsomming><span style='mso-bookmark:bk0'><span lang=EN-US>3.<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>if you find your friend,
stop;</span></span></p>

<p class=opsomming style='page-break-after:avoid'><span style='mso-bookmark:
bk0'><span lang=EN-US>4.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>otherwise,
if there are any doors marked exit in the room,</span></span></p>

<p class=opsomming style='margin-left:85.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>4a.<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>choose one of
them;</span></span></p>

<p class=opsomming style='margin-left:85.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>4b.<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>remove the mark
exit;</span></span></p>

<p class=opsomming style='margin-left:85.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>4c.<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>go through it;</span></span></p>

<p class=opsomming style='margin-left:85.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>4d.<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>if one of the
doors in this room is already marked entrance, go back to the previous room,
and go to step 4;</span></span></p>

<p class=opsomming style='margin-left:85.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>4d.<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>otherwise, mark
the door you just came through as entrance;</span></span></p>

<p class=opsomming style='margin-left:85.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>4e.<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>mark all other
doors as exit;</span></span></p>

<p class=opsomming style='margin-left:85.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>4f.<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>go to step 2;</span></span></p>

<p class=opsomming style='margin-bottom:6.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>5.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>otherwise,
take the door marked entrance, and go to step 4.</span></span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm'>
  <p class=figure><span style='mso-bookmark:bk0'><span lang=EN-US
  style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape id="Picture_x0020_8"
   o:spid="_x0000_i1028" type="#_x0000_t75" style='width:220pt;height:223pt;
   visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20II_files/image013.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=222 height=225
  src="Part%20II_files/image014.png" v:shapes="Picture_x0020_8"><![endif]></span></span></p>
  </div>
  <p class=Caption1><span style='mso-bookmark:bk0'><b style='mso-bidi-font-weight:
  normal'><span lang=EN-US>Figure 5.2.</span></b><span lang=EN-US> You find her
  by systematically searching the rooms, backtracking when all the rooms
  reachable from the room youre in <br>
  have been visited already (thin lines). </span></span></p>
  </td>
 </tr>
</table>

</div>

<p class=tekst><span style='mso-bookmark:bk0'><span lang=EN-US>Steps 1-3 are
obvious enough. In step 4, you check whether there are any untried doors left;
if not, you have to go back to a previously visited room, and do the same there
(step 5). This process of reconsidering previous decisions is called <i
style='mso-bidi-font-style:normal'>backtracking</i></span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;backtracking&quot; \b </span></i></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>. It is an essential step in any
exhaustive search procedure. If there are any alternatives left, you have to
check whether you have been there already via some other route (step 4d). This
step is called <i style='mso-bidi-font-style:normal'>loop detection</i></span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;loop detection&quot; </span></i></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>, and is only needed for cyclic</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search
space:cyclic&quot; </span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>search spaces. If you omit this step in
such cases, you risk walking in circles forever. If you are in a yet unvisited
room, you do some bookkeeping and proceed in the same way.</span></span></p>

<p class=sektie><span style='mso-bookmark:bk0'><span lang=EN-US>How does this
search procedure work in practice? Suppose you are in the </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Mir</span><span
lang=EN-US> room (fig. 5.1). You decide to try the doors in that room in a
clockwise order. You first check the </span></span><span style='mso-bookmark:
bk0'><span lang=EN-US style='font-family:Helvetica'>Lger</span><span
lang=EN-US> room, then the </span></span><span style='mso-bookmark:bk0'><span
lang=EN-US style='font-family:Helvetica'>Kupka</span><span lang=EN-US> room,
and finally the </span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Kandinsky</span><span lang=EN-US> room. When you
enter the </span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Lger</span><span lang=EN-US> room again from </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Kandinsky</span><span
lang=EN-US>, you realise that youve been there before, because theres a door
marked entrance. So you backtrack to </span></span><span style='mso-bookmark:
bk0'><span lang=EN-US style='font-family:Helvetica'>Lger</span><span
lang=EN-US> (because there are no alternatives left in </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Kandinsky</span><span
lang=EN-US> and </span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Kupka</span><span lang=EN-US>), and try the next
door. This one leads you straight to </span></span><span style='mso-bookmark:
bk0'><span lang=EN-US style='font-family:Helvetica'>Kandinsky</span><span
lang=EN-US> again, and your little papers remind you that you have been there
already. You backtrack again to </span></span><span style='mso-bookmark:bk0'><span
lang=EN-US style='font-family:Helvetica'>Lger</span><span lang=EN-US>, and try
the </span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Matisse</span><span lang=EN-US> room. From there,
</span></span><span style='mso-bookmark:bk0'><span lang=EN-US style='font-family:
Helvetica'>Klee</span><span lang=EN-US> is a dead end, so you backtrack and
finally find your friend still admiring the Mondriaan paintings! The route you
walked is shown in fig. 5.2, (thin lines denote backtracking).</span></span></p>

<p class=sektie><span style='mso-bookmark:bk0'><span lang=EN-US>In a computer
implementation of such a search procedure, you dont walk from room to room.
Instead of marking nodes and returning to them later, the search program stores
a description of those nodes in memory. In the above example, the number of
marks needed corresponds to the amount of memory required during search, and
just as marks can be used several times, memory space can be reclaimed once all
the children of a node have been put on the list. This list of nodes to be
tried next is called the <i style='mso-bidi-font-style:normal'>agenda</i></span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;agenda&quot; \b </span></i></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>; this is an important concept, which
can be used to describe any backtracking search procedure. Such a
general-purpose agenda-based search algorithm operates as follows (for
simplicity, we have omitted loop detection):</span></span></p>

<p class=opsomming style='margin-top:6.0pt;page-break-after:avoid'><span
style='mso-bookmark:bk0'><span lang=EN-US>1.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>take
the next node from the agenda;</span></span></p>

<p class=opsomming style='page-break-after:avoid'><span style='mso-bookmark:
bk0'><span lang=EN-US>2.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>if
it is a goal node, stop;</span></span></p>

<p class=opsomming style='page-break-after:avoid'><span style='mso-bookmark:
bk0'><span lang=EN-US>3.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>otherwise,</span></span></p>

<p class=opsomming style='margin-left:85.0pt;page-break-after:avoid'><span
style='mso-bookmark:bk0'><span lang=EN-US>3a.<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>generate
its children;</span></span></p>

<p class=opsomming style='margin-left:85.0pt;page-break-after:avoid'><span
style='mso-bookmark:bk0'><span lang=EN-US>3b.<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>put
them on the agenda;</span></span></p>

<p class=opsomming style='margin-top:0cm;margin-right:28.3pt;margin-bottom:
6.0pt;margin-left:85.0pt'><span style='mso-bookmark:bk0'><span lang=EN-US>3c.<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>go to step 1.</span></span></p>

<p class=tekst><span style='mso-bookmark:bk0'><span lang=EN-US>This procedure
can be almost directly translated into a Prolog program: </span></span></p>

<p class=oms-eerst><span style='mso-bookmark:bk0'><span lang=EN-US>%
search(Agenda,Goal) &lt;- Goal is a goal node, and a <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>descendant of one of the nodes <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>on the Agenda</span></span></p>

<p class=pi><span style='mso-bookmark:bk0'><span lang=EN-US>search</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search/2&quot;
</span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>(Agenda,Goal):-<br>
next(Agenda,Goal,Rest),<br>
goal(Goal).</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk0'><span lang=EN-US>search(Agenda,Goal):-<br>
next(Agenda,Current,Rest),<br>
children(Current,Children),<br>
add(Children,Rest,NewAgenda),<br>
search(NewAgenda,Goal).</span></span></p>

<p class=tekst><span style='mso-bookmark:bk0'><span lang=EN-US>In this program,
we have abstracted from the way the agenda is represented. Furthermore, as
remarked above, by specifying the order in which nodes are added to and removed
from the agenda, we obtain specific search strategies. In the Staatsgalerie
example, doors marked most recently are tried first. In other words, the agenda
is a <i style='mso-bidi-font-style:normal'>last in&#8211;first out</i></span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;last in&#8211;first out&quot; </span></i></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>datastructure, or a <i style='mso-bidi-font-style:
normal'>stack</i></span></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;stack&quot; </span></i></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>. In this example, it seems the most
reasonable approach, because it minimises the amount of walking needed to
backtrack to another room. The result is a <i style='mso-bidi-font-style:normal'>depth-first</i>
search</span></span><!--[if supportFields]><span style='mso-bookmark:bk0'></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk0'><span
lang=EN-US style='display:none;mso-hide:all'> XE </span><i style='mso-bidi-font-style:
normal'><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;depth-first</span></i><span
lang=EN-US> search<i style='mso-bidi-font-style:normal'>&quot; </i></span></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>procedure, moving away as quickly as
possible from the initial room, only coming closer again when backtracking. </span></span></p>

<p class=sektie><span style='mso-bookmark:bk0'><span lang=EN-US>On the other
hand, the shortest path between your initial position and your friend is </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Mir</span><span
lang=EN-US>-</span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Mondriaan</span><span lang=EN-US>, while you
finally reach your friend along the path </span></span><span style='mso-bookmark:
bk0'><span lang=EN-US style='font-family:Helvetica'>Mir</span><span
lang=EN-US>-</span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Lger</span><span lang=EN-US>-</span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Matisse</span><span
lang=EN-US>-</span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Mondriaan</span></span><span style='mso-bookmark:
bk0'></span><a style='mso-footnote-id:ftn4' href="#_ftn4" name="_ftnref4"
title=""><span style='mso-bookmark:bk0'><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span
style='mso-special-character:footnote'><![if !supportFootnotes]><span
class=MsoFootnoteReference><span lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:
Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:
AR-SA'>[15]</span></span><![endif]></span></span></span></span></a><span
style='mso-bookmark:bk0'><span lang=EN-US>. You would have found your friend
sooner if you would have examined all rooms next to </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Mir</span><span
lang=EN-US> first. But suppose your friend was two rooms away, e.g. in the </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Matisse</span><span
lang=EN-US> room? Well, in that case you would have gone to the rooms next to </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Mir</span><span
lang=EN-US> (</span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Lger</span><span lang=EN-US> and </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Mondriaan</span><span
lang=EN-US>), and then to all rooms next to those (</span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Kupka</span><span
lang=EN-US>, </span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Kandinsky</span><span lang=EN-US> and </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Matisse</span><span
lang=EN-US>). That is, doors marked most recently are tried last: a <i
style='mso-bidi-font-style:normal'>first in&#8211;first out</i></span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;first in&#8211;first out&quot; </span></i></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>strategy, implemented by a datastructure
called a <i style='mso-bidi-font-style:normal'>queue</i></span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;queue&quot; </span></i></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>. Thus you would have found your
friend along one of the two shortest paths (</span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Mir</span><span
lang=EN-US>-</span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Lger</span><span lang=EN-US>-</span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Matisse</span><span
lang=EN-US>). This second method is an example of <i style='mso-bidi-font-style:
normal'>breadth-first</i> search</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;breadth-first</span></i><span
lang=EN-US> search<i style='mso-bidi-font-style:normal'>&quot; </i></span></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>. </span></span></p>

<p class=sektie><span style='mso-bookmark:bk0'><span lang=EN-US>Finally, a
third approach called <i style='mso-bidi-font-style:normal'>best-first</i>
search</span></span><!--[if supportFields]><span style='mso-bookmark:bk0'></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk0'><span
lang=EN-US style='display:none;mso-hide:all'> XE </span><i style='mso-bidi-font-style:
normal'><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;best-first</span></i><span
lang=EN-US> search<i style='mso-bidi-font-style:normal'>&quot; </i></span></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>orders the doors to be tried next
according to some criterion called a <i style='mso-bidi-font-style:normal'>heuristic</i></span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;heuristic&quot; </span></i></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>. For instance, suppose you saw your
friend last in the </span></span><span style='mso-bookmark:bk0'><span
lang=EN-US style='font-family:Helvetica'>Mondriaan</span><span lang=EN-US>
room. In this case it would be wise to overrule the default clockwise ordering,
and to try </span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Mondriaan</span><span lang=EN-US> before </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Lger</span><span
lang=EN-US>. Consequently, you would have found your friend along the path </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Mir</span><span
lang=EN-US>-</span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Helvetica'>Mondriaan</span><span lang=EN-US>-</span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Helvetica'>Matisse</span><span
lang=EN-US>. In the following sections, we will take a closer look at
depth-first and breadth-first search. The use of heuristics will be studied in
Chapter 6. <span style='display:none;mso-hide:all'>.;</span></span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Mondriaan,
P.&quot; \r &quot;bk0&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<h3><span lang=EN-US>5.2<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Depth-first
search</span></h3>

<p class=sektie1><span lang=EN-US>We obtain a depth-first search</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;depth-first
search&quot; \b </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>strategy if the agenda
is implemented as a last in&#8211;first out</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;last
in&#8211;first out&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>datastructure. The
obvious way to do this in Prolog is to represent the agenda by a list of nodes,
and to add and remove nodes from the front of the list:</span></p>

<p class=pi-eerst><span lang=EN-US>% depth-first search</span></p>

<p class=pi><span lang=EN-US>search_df</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search_df/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([Goal|Rest],Goal):-<br>
goal(Goal).</span></p>

<p class=pi-laatst><span lang=EN-US>search_df([Current|Rest],Goal):-<br>
children(Current,Children),<br>
append(Children,Rest,NewAgenda),<br>
search_df(NewAgenda,Goal).</span></p>

<p class=tekst><span lang=EN-US>The </span><span lang=EN-US style='font-family:
Courier'>children/2</span><span lang=EN-US> predicate finds all children of a
given node. If arcs in the search space are defined as before by the </span><span
lang=EN-US style='font-family:Courier'>arc/2</span><span lang=EN-US> predicate,
we could define </span><span lang=EN-US style='font-family:Courier'>children/2</span><span
lang=EN-US> as</span></p>

<p class=pi-el><span lang=EN-US>children</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;children/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Node,Children):-<br>
findall(C,arc(Node,C),Children).</span></p>

<p class=tekst><span lang=EN-US>In this way, all children of the current node
are generated and stored on the agenda before examining the next node. </span></p>

<p class=sektie><span lang=EN-US>This depth-first search program can be refined
in several ways, of which we will consider two: returning a path to the goal,
and loop detection. In the above implementation, it is impossible to return a
path if we discover a goal node on the agenda, because we do not know how that
goal node was reached. Instead of putting a single node on the agenda, we will
store a complete path to that node. This is simply accomplished by changing the
</span><span lang=EN-US style='font-family:Courier'>children/2</span><span
lang=EN-US> predicate as follows:</span></p>

<p class=pi-el><span lang=EN-US>children([Node|Path],Children):-<br>
findall([C,Node|Path],arc(Node,C),Children).</span></p>

<p class=tekst><span lang=EN-US>Of course, the </span><span lang=EN-US
style='font-family:Courier'>goal/1</span><span lang=EN-US> predicate must be
changed accordingly, because its argument is now a path instead of a single
node. A query now takes the form</span></p>

<p class=pi-el><span lang=EN-US>?-search_df([[InitialNode]],PathToGoal).</span></p>

<p class=sektie><span lang=EN-US>The second refinement concerns loop detection</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;loop
detection&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. In order to check whether a node has been investigated before, we
must maintain a list of visited nodes. We only add nodes to the agenda which do
not already occur on this list (or on the agenda): </span></p>

<p class=pi-eerst><span lang=EN-US>% depth-first search with loop detection</span></p>

<p class=pi><span lang=EN-US>search_df_loop</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search_df_loop/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([Goal|Rest],Visited,Goal):-<br>
goal(Goal).</span></p>

<p class=pi-laatst><span lang=EN-US>search_df_loop([Current|Rest],Visited,Goal):-<br>
children(Current,Children),<br>
add_df(Children,Rest,Visited,NewAgenda),<br>
search_df_loop(NewAgenda,[Current|Visited],Goal).</span></p>

<p class=pi><span lang=EN-US>add_df</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;add_df/4&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([],Agenda,Visited,Agenda).</span></p>

<p class=pi><span lang=EN-US>add_df([Child|Rest],OldAgenda,Visited,[Child|NewAgenda]):-<br>
not element(Child,OldAgenda),<br>
not element(Child,Visited),<br>
add_df(Rest,OldAgenda,Visited,NewAgenda).</span></p>

<p class=pi><span lang=EN-US>add_df([Child|Rest],OldAgenda,Visited,NewAgenda):-<br>
element(Child,OldAgenda),<br>
add_df(Rest,OldAgenda,Visited,NewAgenda).</span></p>

<p class=pi-laatst><span lang=EN-US>add_df([Child|Rest],OldAgenda,Visited,NewAgenda):-<br>
element(Child,Visited),<br>
add_df(Rest,OldAgenda,Visited,NewAgenda).</span></p>

<p class=sektie><span lang=EN-US>Note that the combination of loop detection
and path construction allows the following optimisation: instead of maintaining
complete paths to a node on the agenda and the list of visited nodes, we only
store a node together with its parent. Once we encounter a goal, all its
parents are on the list of visited nodes, which allows us to reconstruct the
path.</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
5.1.</span></i><span lang=EN-US> Modify the predicate </span><span lang=EN-US
style='font-family:Courier'>search_df_loop/3</span><span lang=EN-US> such that
it reconstructs the path to a goal in this way.</span></p>

</div>

<p class=sektie><span lang=EN-US>We now analyse depth-first search with respect
to completeness, optimality and efficiency. A search strategy is <i
style='mso-bidi-font-style:normal'>complete</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;complete</span></i><span
lang=EN-US>ness:of search strategies<i style='mso-bidi-font-style:normal'>&quot;
\b </i></span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>if it is guaranteed to
find every goal. Obviously, any exhaustive strategy is complete for finite
search spaces. However, in an infinite search space depth-first search might
get trapped in an infinite branch before having found all the solutions. For
instance, reconsider the infinite SLD-tree</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;SLD-tree&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>in fig. 3.2. A
left-to-right depth-first search strategy would dive deeper and deeper into the
tree, taking the left branch at every node, and never find the goals in the
branches to the right. So, <i style='mso-bidi-font-style:normal'>depth-first
search</i></span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;depth-first search</span></i><span
lang=EN-US>:incompleteness<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>is, in general, incomplete</span></i><span
lang=EN-US>. Since Prolog itself employs depth-first search, Prolog</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:incompleteness&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is also incomplete.
Often, however, the incompleteness of Prolog can be avoided by reordering the
clauses such that goals are found before infinite branches (for instance, by
putting the recursive clause last), and to cut away the infinite parts of the
search space. </span></p>

<p class=sektie><span lang=EN-US>If there is no cost function</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;cost
function&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, a search strategy is optimal if it is guaranteed to reach any goal
along the shortest path possible.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;optimality:of
search strategies&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>The Staatsgalerie
example</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Stuttgart
Staatsgalerie example&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>already showed that this
is not true for depth-first search: you found your friend but, while she was in
a room next to your initial position, you finally reached that room through two
other rooms. Thus, <i style='mso-bidi-font-style:normal'>depth-first search
does not always find a shortest solution path</i>.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;depth-first
search:non-optimality&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>Finally, we can estimate
the memory requirements for depth-first search</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;depth-first
search:memory requirements&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>as follows. Suppose we
are searching a tree in which each node has, on the average, <i
style='mso-bidi-font-style:normal'>B</i> children. The number <i
style='mso-bidi-font-style:normal'>B</i> is known as the <i style='mso-bidi-font-style:
normal'>branching factor</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;branching factor&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Generating the children of a node adds <i style='mso-bidi-font-style:
normal'>B</i> nodes to the agenda. We are interested in the following question:
if a goal is found at depth <i style='mso-bidi-font-style:normal'>n</i> (i.e.
the path from the root to the goal has length <i style='mso-bidi-font-style:
normal'>n</i>), how many nodes are there on the agenda? Since at each level
only the children of a single node are generated, the size of the agenda is of
the order <i style='mso-bidi-font-style:normal'>B</i></span><span lang=EN-US
style='font-family:Symbol;letter-spacing:-1.75pt'> </span><span lang=EN-US
style='font-family:Symbol'><span style='letter-spacing:-1.75pt'> </span></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US>n</span></i><span
lang=EN-US>, that is, a linear function of the depth of the tree. The time
complexity</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;depth-first
search:time complexity&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of depth-first search is
of the order <i style='mso-bidi-font-style:normal'>B</i></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US style='font-size:9.0pt;
position:relative;top:-3.0pt;mso-text-raise:3.0pt'>n</span></i><span
lang=EN-US>, since the runtime is proportional to the number of nodes searched,
and in the worst case the goal is found in the last branch, after searching <i
style='mso-bidi-font-style:normal'>B</i></span><i style='mso-bidi-font-style:
normal'><span lang=EN-US style='font-size:9.0pt;position:relative;top:-3.0pt;
mso-text-raise:3.0pt'>n</span></i><b style='mso-bidi-font-weight:normal'><span
lang=EN-US style='font-family:"Avant Garde"'><span
style="mso-spacerun:yes">&nbsp;</span></span></b><span lang=EN-US>nodes. Of
course, we cannot hope to achieve any better for blind exhaustive search!</span></p>

<p class=sektie><span lang=EN-US>In practice, depth-first search is only
implemented as above if loop detection is an absolute must. Otherwise, the
agenda is represented <i style='mso-bidi-font-style:normal'>implicitly</i> by
means of Prologs internal goal stack</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:goal
stack&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Children of a given node are generated one at a time, by means of
Prologs backtracking</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:backtracking&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>mechanism, and examined
immediately upon generation: </span></p>

<p class=pi-eerst><span lang=EN-US>% depth-first search by means of
backtracking</span></p>

<p class=pi><span lang=EN-US>search_bt</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search_bt/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Goal,Goal):-<br>
goal(Goal).</span></p>

<p class=pi-laatst><span lang=EN-US>search_bt(Current,Goal):-<br>
arc(Current,Child),<br>
search_bt(Child,Goal).</span></p>

<p class=tekst><span lang=EN-US>If there is a chance that the search program
gets trapped in an infinite loop, it might be a good idea to employ a
predefined <i style='mso-bidi-font-style:normal'>depth bound</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;depth bound&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: </span></p>

<p class=pi-eerst><span lang=EN-US>% backtracking depth-first search with depth
bound</span></p>

<p class=pi><span lang=EN-US>search_d</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search_d/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(D,Goal,Goal):-<br>
goal(Goal).</span></p>

<p class=pi-laatst><span lang=EN-US>search_d(D,Current,Goal):-<br>
D&gt;0, D1 is D-1,<br>
arc(Current,Child),<br>
search_d(D1,Child,Goal).</span></p>

<p class=tekst><span lang=EN-US>In this way the search process is guaranteed to
halt, but solutions which appear beyond the depth bound are missed. </span></p>

<p class=sektie><i style='mso-bidi-font-style:normal'><span lang=EN-US>Iterative
deepening</span></i><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Iterative deepening&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is a form of depth-first
search which employs a depth bound that is increased on each iteration. That
is, after performing a depth-first search with depth bound <i style='mso-bidi-font-style:
normal'>d</i>, search starts all over again from the starting nodes with an
increased depth bound <i style='mso-bidi-font-style:normal'>d</i>+<i
style='mso-bidi-font-style:normal'>n</i>. The predicate </span><span
lang=EN-US style='font-family:Courier'>search_id/2</span><span lang=EN-US>
implements iterative deepening for <i style='mso-bidi-font-style:normal'>n</i>=1.</span></p>

<p class=pi-eerst style='tab-stops:226.0pt'><span lang=EN-US>% iterative
deepening</span></p>

<p class=pi-laatst style='tab-stops:226.0pt'><span lang=EN-US>search_id</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search_id/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(First,Goal):-<br>
search_id(1,First,Goal).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
start with depth 1</span></p>

<p class=pi style='tab-stops:226.0pt'><span lang=EN-US>search_id(D,Current,Goal):-<br>
search_d(D,Current,Goal).</span></p>

<p class=pi-laatst style='tab-stops:226.0pt'><span lang=EN-US>search_id(D,Current,Goal):-<br>
D1 is D+1,<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
increase depth<br>
search_id(D1,Current,Goal).</span></p>

<p class=tekst><span lang=EN-US>A big advantage of iterative deepening</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;iterative
deepening:completeness&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>over simple depth-first search
is that iterative deepening is complete: it will find all the goals at depth <i
style='mso-bidi-font-style:normal'>d</i> and less before proceeding to depth <i
style='mso-bidi-font-style:normal'>d</i>+<i style='mso-bidi-font-style:normal'>n</i>.
Moreover, if we set the depth increment <i style='mso-bidi-font-style:normal'>n</i>
to 1, iterative deepening</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;iterative
deepening:optimality&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is also optimal: it will
find shorter paths first. A disadvantage of iterative deepening is that upper
parts of the search space are searched more than once (and goals in those upper
parts are found more than once as well). </span></p>

<h3><span lang=EN-US>5.3<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Breadth-first
search</span></h3>

<p class=sektie1><span lang=EN-US>Breadth-first search is realised by
implementing the agenda as a first in&#8211;first out</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;first
in&#8211;first out&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>datastructure. That is,
while removing nodes from the front of the list, they are added at the end:</span></p>

<p class=pi-eerst><span lang=EN-US>% breadth-first search</span></p>

<p class=pi><span lang=EN-US>search_bf</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search_bf/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([Goal|Rest],Goal):-<br>
goal(Goal).</span></p>

<p class=pi-laatst><span lang=EN-US>search_bf([Current|Rest],Goal):-<br>
children(Current,Children),<br>
append(Rest,Children,NewAgenda),<br>
search_bf(NewAgenda,Goal).</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
5.2.</span></i><span lang=EN-US> Implement the predicate </span><span
lang=EN-US style='font-family:Courier'>term_write_bf/1</span><span lang=EN-US>,
which writes the tree represented by a term from the root downward (as opposed
to the predicate </span><span lang=EN-US style='font-family:Courier'>term_write/1</span><span
lang=EN-US> of section 4.1, which writes from left to right). Employ
breadth-first search with two agendas, one for nodes at depth <i
style='mso-bidi-font-style:normal'>n</i> and the other for nodes at depth <i
style='mso-bidi-font-style:normal'>n</i>+1.</span></p>

</div>

<p class=sektie><span lang=EN-US>In breadth-first search, the agenda is
implemented as a queue</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;queue&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. This means that the nodes on the agenda are ordered according to
increasing depth: all the nodes on depth <i style='mso-bidi-font-style:normal'>n</i>
occur before the nodes on depth <i style='mso-bidi-font-style:normal'>n</i>+1.
This has profound consequences with regard to the properties of breadth-first
search. First of all, <i style='mso-bidi-font-style:normal'>breadth-first
search</i></span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;breadth-first search</span></i><span
lang=EN-US>:completeness<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>is complete</span></i><span lang=EN-US>,
even for infinite search spaces. This is so because every goal on depth <i
style='mso-bidi-font-style:normal'>n</i> will be found before descending to
depth <i style='mso-bidi-font-style:normal'>n</i>+1. Secondly, <i
style='mso-bidi-font-style:normal'>breadth-first search</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;breadth-first search</span></i><span
lang=EN-US>:optimality<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>always finds a shortest solution path</span></i><span
lang=EN-US>. It may seem that breadth-first search is much better than
depth-first search. However, like every coin this one has a reverse side also:
the number of nodes at depth <i style='mso-bidi-font-style:normal'>n</i> is <i
style='mso-bidi-font-style:normal'>B</i></span><i style='mso-bidi-font-style:
normal'><span lang=EN-US style='font-size:9.0pt;position:relative;top:-3.0pt;
mso-text-raise:3.0pt'>n</span></i><span lang=EN-US>, such that breadth-first
search</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;breadth-first
search:memory requirements&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>requires much more
memory than depth-first search.</span></p>

<p class=sektie><span lang=EN-US>We will now show how to change Prolog</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:breadth-first
version of&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>into a <i
style='mso-bidi-font-style:normal'>complete</i> SLD prover, by employing
breadth-first search. We start from the meta-interpreter </span><span
lang=EN-US style='font-family:Courier'>prove_r/1</span><span lang=EN-US> given
in section 3.8:</span></p>

<p class=pi-eerst><span lang=EN-US>prove_r</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;prove_r/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(true):-!.</span></p>

<p class=pi><span lang=EN-US>prove_r((A,B)):-!,<br>
clause(A,C),<br>
conj_append(C,B,D),<br>
prove_r(D).</span></p>

<p class=pi-laatst><span lang=EN-US>prove_r(A):-<br>
clause(A,B),<br>
prove_r(B).</span></p>

<p class=tekst><span lang=EN-US>As explained in that section, this
meta-interpreter operates on the complete resolvent, which is exactly what we
need. This predicate is turned into an agenda-based depth-first search
procedure as follows: </span></p>

<p class=oms-eerst><span lang=EN-US>% agenda-based version of prove_r/1</span></p>

<p class=pi-laatst><span lang=EN-US>prove_df</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;prove_df/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Goal):-<br>
prove_df_a([Goal]).</span></p>

<p class=pi><span lang=EN-US>prove_df_a([true|Agenda]).</span></p>

<p class=pi><span lang=EN-US>prove_df_a([(A,B)|Agenda]):-!,<br>
findall(D,(clause(A,C),conj_append(C,B,D)),Children),<br>
append(Children,Agenda,NewAgenda),<br>
prove_df_a(NewAgenda).</span></p>

<p class=pi-laatst><span lang=EN-US>prove_df_a([A|Agenda]):-<br>
findall(B,clause(A,B),Children),<br>
append(Children,Agenda,NewAgenda),<br>
prove_df_a(NewAgenda).</span></p>

<p class=tekst><span lang=EN-US>The changes are relatively straightforward: all
solutions to the calls in the bodies of the second and third </span><span
lang=EN-US style='font-family:Courier'>prove_r</span><span lang=EN-US> clauses
are collected by means of the predicate </span><span lang=EN-US
style='font-family:Courier'>findall/3</span><span lang=EN-US>, and added to the
front of the agenda. </span></p>

<p class=sektie><span lang=EN-US>In order to search in a breadth-first fashion,
we swap the first two arguments of the </span><span lang=EN-US
style='font-family:Courier'>append/3</span><span lang=EN-US> literals. One
additional improvement is required, since </span><span lang=EN-US
style='font-family:Courier'>prove_df/1</span><span lang=EN-US> succeeds for
every proof that can be found, but it does not return an answer substitution</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;answer
substitution&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>for the variables in the
query. This is because the call </span><span lang=EN-US style='font-family:
Courier'>findall</span><!--[if supportFields]><span lang=EN-US
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;findall/3&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]--><span lang=EN-US
style='font-family:Courier'>(X,G,L)</span><span lang=EN-US> creates new
variables for the unbound variables in the instantiation of </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US> before putting
it in the list </span><span lang=EN-US style='font-family:Courier'>L</span><span
lang=EN-US>. In order to obtain an answer substitution, we should maintain the
agenda as a list of pairs </span></p>

<p class=p-el><span lang=EN-US>a(Literals,OrigGoal)</span></p>

<p class=tekst><span lang=EN-US>where </span><span lang=EN-US style='font-family:
Courier'>OrigGoal</span><span lang=EN-US> is a copy of the original goal. To
illustrate this, suppose the following clauses are given:</span></p>

<p class=p-el style='mso-pagination:widow-orphan'><span lang=EN-US>likes(peter,Y):-student(Y),friendly(Y).<br>
likes(X,Y):-friend(Y,X).<br>
student(maria).<br>
student(paul).<br>
friendly(maria).<br>
friend(paul,peter).</span></p>

<p class=tekst><span lang=EN-US>Below, the agenda obtained after each
breadth-first search iteration is given for the query </span><span lang=EN-US
style='font-family:Courier'>?&#8209;likes(X,Y)</span><span lang=EN-US>: </span></p>

<p class=p-el><span lang=EN-US>[ a((student(Y1),friendly(Y1)),
likes(peter,Y1)),<br>
<span style="mso-spacerun:yes">&nbsp; </span>a(friend(Y2,X2), likes(X2,Y2)) ]</span></p>

<p class=p-laatst><span lang=EN-US>[ a(friend(Y2,X2), likes(X2,Y2))<br>
<span style="mso-spacerun:yes">&nbsp; </span>a(friendly(maria),
likes(peter,maria)),<br>
<span style="mso-spacerun:yes">&nbsp; </span>a(friendly(paul),
likes(peter,paul)) ]</span></p>

<p class=p-laatst><span lang=EN-US>[ a(friendly(maria), likes(peter,maria)),<br>
<span style="mso-spacerun:yes">&nbsp; </span>a(friendly(paul),
likes(peter,paul)),<br>
<span style="mso-spacerun:yes">&nbsp; </span>a(true, likes(peter,paul)) ]</span></p>

<p class=p-laatst><span lang=EN-US>[ a(friendly(paul), likes(peter,paul)),<br>
<span style="mso-spacerun:yes">&nbsp; </span>a(true, likes(peter,paul)),<br>
<span style="mso-spacerun:yes">&nbsp; </span>a(true, likes(peter,maria)) ]</span></p>

<p class=p-laatst><span lang=EN-US>[ a(true, likes(peter,paul)),<br>
<span style="mso-spacerun:yes">&nbsp; </span>a(true, likes(peter,maria)) ]</span></p>

<p class=tekst><span lang=EN-US>Here, </span><span lang=EN-US style='font-family:
Courier'>Y1</span><span lang=EN-US>, </span><span lang=EN-US style='font-family:
Courier'>X2</span><span lang=EN-US> and </span><span lang=EN-US
style='font-family:Courier'>Y2</span><span lang=EN-US> denote new variables
introduced by </span><span lang=EN-US style='font-family:Courier'>findall/3</span><span
lang=EN-US>. It can be clearly seen that for each item </span><span lang=EN-US
style='font-family:Courier'>a(R,G)</span><span lang=EN-US> on the agenda, </span><span
lang=EN-US style='font-family:Courier'>R</span><span lang=EN-US> and </span><span
lang=EN-US style='font-family:Courier'>G</span><span lang=EN-US> share the
right variables &#8212; thus, whenever the resolvent gets more instantiated
during the proof, the corresponding copy of the goal is instantiated
correspondingly. In particular, if the empty clause is found on the agenda in
the form of a term </span><span lang=EN-US style='font-family:Courier'>a(true,Goal)</span><span
lang=EN-US>, then </span><span lang=EN-US style='font-family:Courier'>Goal</span><span
lang=EN-US> will contain the correct answer substitutions. </span></p>

<p class=sektie><span lang=EN-US>The final, complete SLD prover looks as
follows: </span></p>

<p class=oms-eerst><span lang=EN-US>% breadth-first version of prove_r/1 +
answer substitution</span></p>

<p class=pi-laatst><span lang=EN-US>prove_bf</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;prove_bf/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Goal):-<br>
prove_bf_a([a(Goal,Goal)],Goal).</span></p>

<p class=pi><span lang=EN-US>prove_bf_a([a(true,Goal)|Agenda],Goal).</span></p>

<p class=pi><span lang=EN-US>prove_bf_a([a((A,B),G)|Agenda],Goal):-!,<br>
findall(a(D,G),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(clause(A,C),conj_append(C,B,D)),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Children),<br>
append(Agenda,Children,NewAgenda),<span style='mso-tab-count:1'> </span>%
breadth-first<br>
prove_bf_a(NewAgenda,Goal).</span></p>

<p class=pi-laatst><span lang=EN-US>prove_bf_a([a(A,G)|Agenda],Goal):-<br>
findall(a(B,G),clause(A,B),Children),<br>
append(Agenda,Children,NewAgenda),<span style='mso-tab-count:1'> </span>%
breadth-first<br>
prove_bf_a(NewAgenda,Goal).</span></p>

<p class=tekst><span lang=EN-US>Notice that this program is able to find
alternative solutions, since it will backtrack from the first clause into the
third and, being unable to find a clause for the predicate </span><span
lang=EN-US style='font-family:Courier'>true/0</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;true/0&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, </span><span lang=EN-US style='font-family:Courier'>findall/3</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;findall/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>will generate an empty
list of children and search will proceed with the rest of the agenda. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm;tab-stops:48.0pt 114.0pt'><i style='mso-bidi-font-style:normal'><span
lang=EN-US>Exercise 5.3.</span></i><span lang=EN-US> Consider the following
program:<br>
</span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>brother(peter,paul).<br>
<span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>brother(adrian,paul).<br>
<span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>brother(X,Y):-brother(Y,X).<br>
<span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>brother(X,Y):-brother(X,Z),brother(Z,Y).<br>
</span><span lang=EN-US>Compare and explain the behaviour of </span><span
lang=EN-US style='font-family:Courier'>prove_bf/1</span><span lang=EN-US> and
Prolog on the query </span><span lang=EN-US style='font-family:Courier'>?&#8209;brother(peter,adrian)</span><span
lang=EN-US>. Can you re-order the clauses, such that Prolog succeeds? </span></p>

</div>

<p class=sektie><span lang=EN-US>As a second, related example of a
breadth-first search program, we give a program for finding refutation proofs
in full clausal logic</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;full
clausal logic:finding refutation proofs&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Object-level</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Object-level&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>clauses are given by the
predicate </span><span lang=EN-US style='font-family:Courier'>cl/1</span><span
lang=EN-US>. Note that </span><span lang=EN-US style='font-family:Courier'>true</span><span
lang=EN-US> denotes the empty body, while </span><span lang=EN-US
style='font-family:Courier'>false</span><span lang=EN-US> denotes the empty
head; thus, </span><span lang=EN-US style='font-family:Courier'>false:-true</span><span
lang=EN-US> denotes the empty clause</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;empty
clause&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. </span></p>

<p class=oms-eerst><span lang=EN-US>% refute_bf(Clause) &lt;- Clause is refuted
by clauses <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>defined by cl/1 <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(breadth-first search strategy)</span></p>

<p class=pi-laatst><span lang=EN-US>refute_bf</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;refute_bf/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Clause):-<br>
refute_bf_a([a(Clause,Clause)],Clause).</span></p>

<p class=pi><span lang=EN-US>refute_bf_a([a((false:-true),Clause)|Rest],Clause).</span></p>

<p class=pi-laatst><span lang=EN-US>refute_bf_a([a(A,C)|Rest],Clause):-<br>
findall(a(R,C),(cl(Cl),resolve(A,Cl,R)),Children),<br>
append(Rest,Children,NewAgenda),<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%
breadth-first<br>
refute_bf_a(NewAgenda,Clause).</span></p>

<p class=pi><span lang=EN-US>% resolve(C1,C2,R) &lt;- R is the resolvent of C1
and C2.</span></p>

<p class=pi><span lang=EN-US>resolve</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;resolve/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>((H1:-B1),(H2:-B2),(ResHead:-ResBody)):-<br>
resolve(H1,B2,R1,R2),<br>
disj_append(R1,H2,ResHead),<br>
conj_append(B1,R2,ResBody).</span></p>

<p class=pi-laatst><span lang=EN-US>resolve((H1:-B1),(H2:-B2),(ResHead:-ResBody)):-<br>
resolve(H2,B1,R2,R1),<br>
disj_append(H1,R2,ResHead),<br>
conj_append(R1,B2,ResBody).</span></p>

<p class=pi><span lang=EN-US>resolve((A;B),C,B,E):-<br>
conj_remove_one(A,C,E).</span></p>

<p class=pi><span lang=EN-US>resolve((A;B),C,(A;D),E):-<br>
resolve(B,C,D,E).</span></p>

<p class=pi-laatst><span lang=EN-US>resolve(A,C,false,E):-<br>
conj_remove_one(A,C,E).</span></p>

<p class=p-laatst><span lang=EN-US>%%% disj_append/3, conj_remove_one/3: see
Appendix A.2</span></p>

<p class=tekst><span lang=EN-US>For instance, given the following clauses: </span></p>

<p class=p-el><span lang=EN-US>cl((bachelor(X);married(X):-man(X),adult(X))).<br>
cl((has_wife(X):-man(X),married(X))).<br>
cl((false:-has_wife(paul))).<br>
cl((man(paul):-true)).<br>
cl((adult(paul):-true)).</span></p>

<p class=tekst><span lang=EN-US>and the query </span><span lang=EN-US
style='font-family:Courier'>?-refute_bf((false:-bachelor(X)))</span><span
lang=EN-US> (refute that no-one is a bachelor), the program answers </span><span
lang=EN-US style='font-family:Courier'>X=paul</span><span lang=EN-US>. Note
that there are many proofs for this answer! </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
5.4</span></i><span lang=EN-US>. Extend the meta-interpreter, such that it
returns a proof tree (see section 3.8). In order to ensure correct variable
substitutions, each item on the agenda must be extended with a partial proof
tree. </span></p>

</div>

<p class=sektie><span lang=EN-US>As a search program, the above program is
complete</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;completeness:of
search strategies&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. As a theorem prover, however, the program is incomplete.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;theorem
proving&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;completeness:in logic&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>This is due to the resolution
strategy</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;resolution:
strategy&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>used, in which every
resolvent</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;resolvent&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>has at least one given
clause as its parent. This strategy is called <i style='mso-bidi-font-style:
normal'>input</i> resolution</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;input</span></i><span lang=EN-US>
resolution<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>; it is refutation complete for definite clause</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;definite
clause&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s, but not for indefinite clause</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;indefinite
clause&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s.</span></p>

<h3><span lang=EN-US>5.4<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Forward
chaining</span></h3>

<p class=sektie1><span lang=EN-US>Search programs involving if-then rule</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;if-then
rule&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s, such as meta-interpreter</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;meta-interpreter&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s and theorem provers, can use these rules in either of two
directions: from body to head or forward, and from head to body or backward.
The meta-interpreters we encountered up till now apply clauses backward, just
like Prolog; they are said to perform <i style='mso-bidi-font-style:normal'>backward
chaining</i></span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;backward chaining&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. For checking if a given formula follows logically from a given
theory, this is usually the best strategy.</span></p>

<p class=sektie><span lang=EN-US>However, in some cases we must rather perform <i
style='mso-bidi-font-style:normal'>forward chaining</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;forward chaining&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, because we do not have a goal to start from. For instance,
consider the problem of constructing a model of a given theory. It would not be
feasible to generate all the ground atoms in the Herbrand base and follow the
chains back to the theory. Rather, we would generate the model incrementally by
forward chaining. The procedure is as follows:</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>i</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>search for a violated clause
of which the body is true in the current model, but the head is not (such a
clause is said to <i style='mso-bidi-font-style:normal'>fire</i>);</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;firing
of a rule&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>ii</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>add a literal from the head to the
model</span><a style='mso-footnote-id:ftn5' href="#_ftn5" name="_ftnref5"
title=""><span class=MsoFootnoteReference><span lang=EN-US style='font-size:
8.0pt;mso-bidi-font-size:10.0pt'><span style='mso-special-character:footnote'><![if !supportFootnotes]><span
class=MsoFootnoteReference><span lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:
Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:
AR-SA'>[16]</span></span><![endif]></span></span></span></a><span lang=EN-US>.</span></p>

<p class=tekst><span lang=EN-US>By step (<i style='mso-bidi-font-style:normal'>ii</i>),
the head (a disjunction</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;disjunction&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>) is made true in the model, so that this clause is no longer
violated. The procedure iterates back to step (<i style='mso-bidi-font-style:
normal'>i</i>); if no violated clauses remain, the model is complete.</span></p>

<p class=sektie><span lang=EN-US>The program for model generation</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;model
generation&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>by forward chaining is
given below. It is a fairly simple forward chainer, in the sense that it simply
chooses the first clause which fires. More sophisticated forward chainers use <i
style='mso-bidi-font-style:normal'>conflict resolution</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;conflict resolution&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>strategies in order to
choose among the rules which fire at a certain stage.</span></p>

<p class=oms-eerst><span lang=EN-US>% model(M) &lt;- M is a model of the
clauses defined by cl/1</span></p>

<p class=pi-laatst style='tab-stops:198.0pt'><span lang=EN-US>model</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;model/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(M):-<br>
model([],M).</span></p>

<p class=pi style='tab-stops:188.0pt'><span lang=EN-US>model(M0,M):-<br>
is_violated(Head,M0),!,<span style='mso-tab-count:1'> </span>% instance of
violated clause<br>
disj_element(L,Head),<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>% L:
ground literal from head<br>
model([L|M0],M).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
add L to the model</span></p>

<p class=pi-laatst style='tab-stops:188.0pt'><span lang=EN-US>model(M,M).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
no more violated clauses</span></p>

<p class=pi-laatst style='tab-stops:188.0pt'><span lang=EN-US>is_violated(H,M):-<br>
cl((H:-B)),<br>
satisfied_body(B,M),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>%
grounds the variables<br>
not satisfied_head(H,M).</span></p>

<p class=pi style='tab-stops:188.0pt'><span lang=EN-US>satisfied_body(true,M).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>% body is a
conjunction</span></p>

<p class=pi style='tab-stops:188.0pt'><span lang=EN-US>satisfied_body(A,M):-<br>
element(A,M).</span></p>

<p class=pi-laatst style='tab-stops:188.0pt'><span lang=EN-US>satisfied_body((A,B),M):-<br>
element(A,M),<br>
satisfied_body(B,M).</span></p>

<p class=pi style='tab-stops:188.0pt'><span lang=EN-US>satisfied_head(A,M):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
head is a disjunction<br>
element(A,M).</span></p>

<p class=pi style='tab-stops:188.0pt'><span lang=EN-US>satisfied_head((A;B),M):-<br>
element(A,M).</span></p>

<p class=pi-laatst style='tab-stops:188.0pt'><span lang=EN-US>satisfied_head((A;B),M):-<br>
satisfied_head(B,M).</span></p>

<p class=pi-laatst><span lang=EN-US>%%% disj_element/2: see Appendix A.2</span></p>

<p class=tekst><span lang=EN-US>Given the following clauses: </span></p>

<p class=p-el><span lang=EN-US>cl((married(X);bachelor(X):-man(X),adult(X))).<br>
cl((has_wife(X):-married(X),man(X))).<br>
cl((man(paul):-true)).<br>
cl((adult(paul):-true)).</span></p>

<p class=tekst><span lang=EN-US>and the query </span><span lang=EN-US
style='font-family:Courier'>?-model(M)</span><span lang=EN-US>, the program
constructs the following models (on backtracking):</span></p>

<p class=p-el><span lang=EN-US>M =
[has_wife(paul),married(paul),adult(paul),man(paul)];</span></p>

<p class=p-laatst><span lang=EN-US>M = [bachelor(paul),adult(paul),man(paul)]</span></p>

<p class=tekst><span lang=EN-US>Notice that these are the two minimal model</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;minimal
model&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s of the program.</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
5.5</span></i><span lang=EN-US>. Give the remaining models of the program.</span></p>

</div>

<p class=sektie><span lang=EN-US>Not every model generated by </span><span
lang=EN-US style='font-family:Courier'>model/1</span><span lang=EN-US> is
minimal. Consider the following set of clauses:</span></p>

<p class=p-el><span lang=EN-US>cl((likes(peter,maria):-true)).<br>
cl((student(maria):-true)).<br>
cl((teacher(X);friendly(Y):-likes(X,Y),student(Y))).<br>
cl((friendly(Y):-teacher(X),likes(X,Y))).</span></p>

<p class=tekst><span lang=EN-US style='font-family:Courier'>is_violated/2</span><span
lang=EN-US> will first succeed for the third clause, returning the instantiated
head </span><span lang=EN-US style='font-family:Courier'>teacher(peter);friendly(maria)</span><span
lang=EN-US>. The first literal in this head will be added to the model. Next,
the fourth clause is violated, and </span><span lang=EN-US style='font-family:
Courier'>friendly(maria)</span><span lang=EN-US> is added to the model. This
results in the following model:</span></p>

<p class=p-el><span lang=EN-US>[friendly(maria),teacher(peter),<br>
<span style="mso-spacerun:yes">&nbsp;</span>student(maria),likes(peter,maria)]</span></p>

<p class=tekst><span lang=EN-US>However, this is not a minimal model since </span><span
lang=EN-US style='font-family:Courier'>teacher(peter)</span><span lang=EN-US>
can be removed from it, yielding the model</span></p>

<p class=pi-el><span lang=EN-US>[friendly(maria),student(maria),likes(peter,maria)]</span></p>

<p class=tekst><span lang=EN-US>which will be returned as the second answer.</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
5.6</span></i><span lang=EN-US>. Are all minimal models always constructed by </span><span
lang=EN-US style='font-family:Courier'>model/1</span><span lang=EN-US>? </span></p>

</div>

<p class=sektie><span lang=EN-US>It should be noted that the program only works
properly for a restricted class of clauses, namely those clauses for which
grounding the body also grounds the head. Otherwise, a head literal from a
violated clause might still contain variables. Adding a non-ground literal to
the model could result in incorrect behaviour. Consider the following set of
clauses:</span></p>

<p class=p-el><span lang=EN-US>cl((man(X);woman(X):-true)).<br>
cl((false:-man(maria))).<br>
cl((false:-woman(peter))).</span></p>

<p class=tekst><span lang=EN-US>Since the first clause is violated by the empty
model, the program will attempt to add </span><span lang=EN-US
style='font-family:Courier'>man(X)</span><span lang=EN-US> to the model. This
leads to the second clause being violated, and since this clause has an empty
head, it cannot be satisfied by adding a literal to the model. Upon
backtracking </span><span lang=EN-US style='font-family:Courier'>woman(X)</span><span
lang=EN-US> is tried instead, but this leads to a similar problem with the
third clause. Consequently, </span><span lang=EN-US style='font-family:Courier'>model/1</span><span
lang=EN-US> will fail to construct a model, although there exists one, namely {</span><span
lang=EN-US style='font-family:Courier'>man(peter)</span><span lang=EN-US>, </span><span
lang=EN-US style='font-family:Courier'>woman(maria)</span><span lang=EN-US>}.</span></p>

<p class=sektie><span lang=EN-US>The solution is to add a literal to the body
of the first clause, which serves to enumerate the possible values for </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US>: </span></p>

<p class=p-el><span lang=EN-US>cl((man(X);woman(X):-person(X))).<br>
cl((person(maria):-true)).<br>
cl((person(peter):-true)).<br>
cl((false:-man(maria))).<br>
cl((false:-woman(peter))).</span></p>

<p class=tekst><span lang=EN-US>In this way, the first clause is violated only
under the substitutions {</span><span lang=EN-US style='font-family:Courier'>X</span><span
lang=EN-US style='font-family:Symbol'></span><span lang=EN-US
style='font-family:Courier'>peter</span><span lang=EN-US>} and {</span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US
style='font-family:Symbol'></span><span lang=EN-US style='font-family:Courier'>maria</span><span
lang=EN-US>}. Thus, all literals which are added to the model are ground, and
the program constructs the correct model</span></p>

<p class=pi-el><span lang=EN-US>[man(peter),person(peter),woman(maria),person(maria)]</span></p>

<p class=tekst><span lang=EN-US>Clauses of which all variables in the head
occur also in the body are called <i style='mso-bidi-font-style:normal'>range-restricted</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;clause:<i
style='mso-bidi-font-style:normal'>range-restricted</i>&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Every set of clauses can be transformed into a set of
range-restricted clauses by adding domain predicates enumerating the domains of
variables, as above. The two sets of clauses are equivalent in the sense that
there exists a one-to-one correspondence between their models:</span></p>

<p class=opsomming style='margin-right:17.0pt'><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>any model of the
original clauses provides an enumeration of all the domains;</span></p>

<p class=opsomming><span lang=EN-US><span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>any
model of the range-restricted clauses can be transformed to a model of the
original clauses by dropping the domain literals.</span></p>

<p class=sektie><span lang=EN-US>Obviously, </span><span lang=EN-US
style='font-family:Courier'>model/1</span><span lang=EN-US> loops if the model
being constructed is infinite. This will happen, for instance, with the following
set of clauses, representing a range-restricted version of the append
predicate:</span></p>

<p class=p-el><span lang=EN-US>cl((append([],Y,Y):-list(Y))).<br>
cl((append([X|Xs],Ys,[X|Zs]):-thing(X),append(Xs,Ys,Zs))).<br>
cl((list([]):-true)).<br>
cl((list([X|Y]):-thing(X),list(Y))).<br>
cl((thing(a):-true)).<br>
cl((thing(b):-true)).<br>
cl((thing(c):-true)).</span></p>

<p class=tekst><span lang=EN-US>Instead of the complete, infinite model, we
might be interested in a subset over a universe of lists up to a given length.
Such a submodel can be computed by a forward chaining procedure which stops
after a prespecified number of steps. In this way, the procedure gets more of a
breadth-first flavour. The program is given below: </span></p>

<p class=oms-eerst><span lang=EN-US>% model_d(D,M) &lt;- M is a submodel of the
clauses <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>defined by cl/1</span></p>

<p class=pi-laatst><span lang=EN-US>model_d</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;model_d/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(D,M):-<br>
model_d(D,[],M).</span></p>

<p class=pi><span lang=EN-US>model_d(0,M,M).</span></p>

<p class=pi-laatst><span lang=EN-US>model_d(D,M0,M):-<br>
D&gt;0,D1 is D-1,<br>
findall(H,is_violated(H,M0),Heads),<br>
satisfy_clauses(Heads,M0,M1),<br>
model_d(D1,M1,M).</span></p>

<p class=pi><span lang=EN-US>satisfy_clauses([],M,M).</span></p>

<p class=pi-laatst><span lang=EN-US>satisfy_clauses([H|Hs],M0,M):-<br>
disj_element(D,H),<br>
satisfy_clauses(Hs,[D|M0],M).</span></p>

<p class=tekst><span lang=EN-US style='font-family:Courier'>model/1</span><span
lang=EN-US> is replaced by </span><span lang=EN-US style='font-family:Courier'>model_d/2</span><span
lang=EN-US>, which has an additional depth parameter. On each iteration, all
the violated clauses are generated and satisfied. </span></p>

<p class=sektie style='page-break-after:avoid'><span lang=EN-US>Below, we
illustrate the operation of the program on the above set of clauses, setting
the depth to 4: </span></p>

<p class=query style='tab-stops:357.0pt'><span lang=EN-US>?-model_d(4,M)</span></p>

<p class=pi-laatst style='margin-left:52.0pt;text-indent:-35.0pt;tab-stops:
327.0pt'><span lang=EN-US>M = [<span style='mso-tab-count:1'> </span>list([a,c,a]),
list([a,c,b]), list([a,c,c]), <span style='mso-tab-count:1'> </span>% D=4 %<br>
list([a,b,a]), list([a,b,b]), list([a,b,c]), <br>
list([a,a,a]), list([a,a,b]), list([a,a,c]), <br>
list([b,c,a]), list([b,c,b]), list([b,c,c]), <br>
list([b,b,a]), list([b,b,b]), list([b,b,c]), <br>
list([b,a,a]), list([b,a,b]), list([b,a,c]), <br>
list([c,c,a]), list([c,c,b]), list([c,c,c]), <br>
list([c,b,a]), list([c,b,b]), list([c,b,c]), <br>
list([c,a,a]), list([c,a,b]), list([c,a,c]), <br>
append([a],[a],[a,a]), append([a],[b],[a,b]), <br>
append([a],[c],[a,c]), append([a,c],[],[a,c]), <br>
append([a,b],[],[a,b]), append([a,a],[],[a,a]), <br>
append([b],[a],[b,a]), append([b],[b],[b,b]), <br>
append([b],[c],[b,c]), append([b,c],[],[b,c]), <br>
append([b,b],[],[b,b]), append([b,a],[],[b,a]), <br>
append([c],[a],[c,a]), append([c],[b],[c,b]), <br>
append([c],[c],[c,c]), append([c,c],[],[c,c]), <br>
append([c,b],[],[c,b]), append([c,a],[],[c,a]), <br>
append([],[c,a],[c,a]), append([],[c,b],[c,b]), <br>
append([],[c,c],[c,c]), append([],[b,a],[b,a]), <br>
append([],[b,b],[b,b]), append([],[b,c],[b,c]), <br>
append([],[a,a],[a,a]), append([],[a,b],[a,b]), <br>
append([],[a,c],[a,c]), <br>
list([a,c]), list([a,b]), list([a,a]), <span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
D=3 %<br>
list([b,c]), list([b,b]), list([b,a]), <br>
list([c,c]), list([c,b]), list([c,a]), <br>
append([a],[],[a]), append([b],[],[b]), <br>
append([c],[],[c]), append([],[c],[c]), <br>
append([],[b],[b]), append([],[a],[a]), <br>
list([a]), list([b]), list([c]), <span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
D=2 %<br>
append([],[],[]), <br>
thing(c), thing(b), thing(a), <span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
D=1 %<br>
list([])<span style="mso-spacerun:yes">&nbsp; </span>]</span></p>

<p class=tekst><span lang=EN-US>At depth 1, only domain clauses are satisfied;
at depth 2 the first </span><span lang=EN-US style='font-family:Courier'>append</span><span
lang=EN-US> literal appears. Depths 3 and 4 add </span><span lang=EN-US
style='font-family:Courier'>list</span><span lang=EN-US> literals for all lists
of length 2 and 3, and </span><span lang=EN-US style='font-family:Courier'>append</span><span
lang=EN-US> literals for all lists of length 1 and 2, respectively. </span></p>

<h3><span lang=EN-US>Further reading</span></h3>

<p class=sektie1><span lang=EN-US>Korf (1987) gives a comprehensive overview of
search methods in Artificial Intelligence. He is also the originator of the
iterative deepening</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;iterative
deepening&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>search strategy (Korf,
1985). The model generation</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;model
generation&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>program in section 5.4
is adapted from (Manthey &amp; Bry, 1988). </span></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>R.E. Korf
(</span><span lang=EN-US>1985)<span style='font-variant:small-caps'>,</span>
Depth-first iterative deepening: an optimal admissible tree search, <i
style='mso-bidi-font-style:normal'>Artificial Intelligence</i> <b
style='mso-bidi-font-weight:normal'>27</b>: 97-109.<span style='display:none;
mso-hide:all'>.E.;</span></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Korf,
R.E.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>R.E. Korf
(</span><span lang=EN-US>1987)<span style='font-variant:small-caps'>,</span>
Search. In <i style='mso-bidi-font-style:normal'>Encyclopedia of Artificial
Intelligence</i>, S.C. Shapiro (ed.), pp. 994-998, John Wiley.<span
style='display:none;mso-hide:all'>.E.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Korf,
R.E.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties style='margin-right:-2.0pt'><span lang=EN-US
style='font-variant:small-caps'>R. Manthey &amp; F. Bry (</span><span
lang=EN-US>1988)<span style='font-variant:small-caps'>,</span> SATCHMO: a
theorem prover implemented in Prolog. In E. Lusk &amp; R. Overbeek (eds), <i
style='mso-bidi-font-style:normal'>Proc. 9th International Conference on
Automated Deduction</i>, Lecture Notes in Computer Science 310, pp. 415-434,
Springer&#8209;Verlag.<span style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Manthey,
R.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Bry,
F.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

</div>

<b style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-size:18.0pt;
mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA'><br clear=all style='page-break-before:right;
mso-break-type:section-break'>
</span></b>

<div class=WordSection4>

<p class=cijfer><span lang=EN-US>6</span></p>

<h2><span lang=EN-US>Informed search</span></h2>

<p class=sektie1><span lang=EN-US>The search strategies of the previous chapter
do not make any assumptions about the plausibility of a certain node in the
search space leading to a goal. Such a form of search is called <i
style='mso-bidi-font-style:normal'>blind</i> search</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;blind</span></i><span lang=EN-US>
search<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Alternatively, search strategies which <b style='mso-bidi-font-weight:
normal'>do</b> make such assumptions are called <i style='mso-bidi-font-style:
normal'>informed</i> search</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;informed</span></i><span
lang=EN-US> search<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>strategies. The extra
information which is incorporated in the search process is provided by an
evaluation function <i style='mso-bidi-font-style:normal'>h</i> called a <i
style='mso-bidi-font-style:normal'>heuristic</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;heuristic&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, which estimates how far a given node is from a goal. This
information can be used in several ways. If we use it to order the nodes on the
agenda</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;agenda:ordering of
nodes&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, such that most promising nodes are tried first, the resulting
search method is called <i style='mso-bidi-font-style:normal'>best-first</i>
search</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;best-first</span></i><span
lang=EN-US> search<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. In section 6.2, we will discuss a complete variant of best-first
search called the <i style='mso-bidi-font-style:normal'>A algorithm</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;A algorithm&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, and investigate the conditions under which this algorithm is
optimal. In section 6.3, we will discuss non-exhaustive informed search
strategies, that can be derived from best-first search by limiting the size of
the agenda. </span></p>

<h3><span lang=EN-US>6.1<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Best-first
search</span></h3>

<p class=sektie1><span lang=EN-US>We will assume that a predicate </span><span
lang=EN-US style='font-family:Courier'>eval/2</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;eval/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is defined, which
returns for a given node in the search space an estimate of the distance
between that node and a goal node. The children of the current node are added
to the agenda according to their heuristic evaluation (lowest values first).
Thus, the agenda will always be sorted. </span></p>

<p class=oms-eerst><span lang=EN-US>% best-first search<br>
% goal/1, children/2 and eval/2 depend on <br>
% the search problem at hand</span></p>

<p class=pi><span lang=EN-US>search_bstf</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search_bstf/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([Goal|Rest],Goal):-<br>
goal(Goal).</span></p>

<p class=pi-laatst><span lang=EN-US>search_bstf([Current|Rest],Goal):-<br>
children(Current,Children),<br>
add_bstf(Children,Rest,NewAgenda),<br>
search_bstf(NewAgenda,Goal).</span></p>

<p class=oms><span lang=EN-US>% add_bstf(A,B,C) &lt;- C contains the elements
of A and B <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(B and C sorted according to eval/2)</span></p>

<p class=pi style='page-break-after:auto'><span lang=EN-US>add_bstf</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;add_bstf/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([],Agenda,Agenda).</span></p>

<p class=pi-laatst><span lang=EN-US>add_bstf([Child|Children],OldAgenda,NewAgenda):-<br>
add_one(Child,OldAgenda,TmpAgenda),<br>
add_bstf(Children,TmpAgenda,NewAgenda).</span></p>

<p class=oms><span lang=EN-US>% add_one(S,A,B) &lt;- B is A with S inserted
acc. to eval/2</span></p>

<p class=pi-laatst><span lang=EN-US>add_one(Child,OldAgenda,NewAgenda):-<br>
eval(Child,Value),<br>
add_one(Value,Child,OldAgenda,NewAgenda).</span></p>

<p class=pi><span lang=EN-US>add_one(Value,Child,[],[Child]).</span></p>

<p class=pi><span lang=EN-US>add_one(Value,Child,[Node|Rest],[Child,Node|Rest]):-<br>
eval(Node,V),<br>
Value&lt;V.</span></p>

<p class=pi-laatst><span lang=EN-US>add_one(Value,Child,[Node|Rest],[Node|NewRest]):-<br>
eval(Node,V),<br>
Value&gt;=V,<br>
add_one(Value,Child,Rest,NewRest).</span></p>

<p class=tekst><span lang=EN-US style='font-family:Courier'>add_bstf/3</span><span
lang=EN-US> operates by inserting the new children one by one in the current
agenda. Note that if the list of children were already sorted, it could more
efficiently be <b style='mso-bidi-font-weight:normal'>merged</b> with the
current agenda.</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
6.1.</span></i><span lang=EN-US> Suppose the call </span><span lang=EN-US
style='font-family:Courier'>children(Current,Children)</span><span lang=EN-US>
results in an ordered list of children. Write a predicate </span><span
lang=EN-US style='font-family:Courier'>merge/3</span><span lang=EN-US> which
directly merges this list with the current agenda.</span></p>

</div>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=med-figure style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm'><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
   id="Picture_x0020_9" o:spid="_x0000_i1027" type="#_x0000_t75" style='width:204pt;
   height:34pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20II_files/image015.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=206 height=36
  src="Part%20II_files/image016.png" v:shapes="Picture_x0020_9"><![endif]></span></p>
  </div>
  <p class=med-caption><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  6.1.</span></b><span lang=EN-US> Initial board position.</span></p>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>As an application of best-first search,
consider the following puzzle</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;sliding
tiles puzzle&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. We have a board consisting of seven consecutive squares, three
black tiles and three white tiles, initially placed on the board as in fig.
6.1. The goal is to move the tiles in such a way that the black tiles are to
the right of the white tiles (the position of the empty square is immaterial).
Each move consists of moving one tile into the empty square, which is allowed
if there are at most two other tiles in between. The cost of such a move is 1
if there are no tiles in between, and equals the number of tiles jumped over
otherwise.</span></p>

<p class=sektie><span lang=EN-US>This puzzle defines a search space, in which
nodes are board positions and arcs are single moves. We choose a simple list
representation for board positions: e.g. </span><span lang=EN-US
style='font-family:Courier'>[b,b,b,e,w,w,w]</span><span lang=EN-US> represents
the starting position of fig. 6.1. The following predicates examine and
manipulate board positions: </span></p>

<p class=oms-eerst><span lang=EN-US>% get_tile(P,N,T) &lt;- pos. P contains
tile T at square N</span></p>

<p class=pi-laatst><span lang=EN-US>get_tile(Pos,N,T):-<br>
get_tile(Pos,1,N,T).</span></p>

<p class=pi><span lang=EN-US>get_tile([X|Xs],N,N,X).</span></p>

<p class=pi-laatst><span lang=EN-US>get_tile([X|Xs],N0,N,Y):-<br>
N1 is N0+1,<br>
get_tile(Xs,N1,N,Y).</span></p>

<p class=oms><span lang=EN-US>% replace(P,N,T,P1) &lt;- P1 is P with tile T at
square N</span></p>

<p class=pi><span lang=EN-US>replace([X|Xs],1,Y,[Y|Xs]).</span></p>

<p class=pi-laatst><span lang=EN-US>replace([X|Xs],N,Y,[X|Zs]):-<br>
N&gt;1, N1 is N-1,<br>
replace(Xs,N1,Y,Zs).</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .25pt;padding:14.0pt 14.0pt 14.0pt 14.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto;
  margin-left:1.0cm;margin-right:1.0cm'>
  <p class=inter-title style='margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>When not to use lists</span><!--[if supportFields]><span
  lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
  XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;list:when
  not to use&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
  style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>Recall (section 1.3) that </span><span
  lang=EN-US style='font-family:Courier'>[b,b,b,e,w,w,w]</span><span
  lang=EN-US> is an alternative notation for the term </span><span lang=EN-US
  style='font-family:Courier'>.(b,.(b,.(b,.(e,.(w,.(w,.(w,[])))))))</span><span
  lang=EN-US>. This term contains, besides the seven constants in the linear
  notation, one additional constant (</span><span lang=EN-US style='font-family:
  Courier'>[]</span><span lang=EN-US>) and seven functors (</span><span
  lang=EN-US style='font-family:Courier'>.</span><span lang=EN-US>), each with
  two arguments. In contrast, a flat term </span><span lang=EN-US
  style='font-family:Courier'>p(b,b,b,e,w,w,w)</span><span lang=EN-US> contains
  only one additional functor, with seven arguments. Recursive datastructures
  like lists are useful if the number of items to be stored is not fixed, but
  they require significantly more storage space. In general, if the number of
  items is fixed, a non-recursive datastructure is preferred as far as memory is
  concerned. Given a term </span><span lang=EN-US style='font-family:Courier'>T</span><span
  lang=EN-US> holding the items, the call </span><span lang=EN-US
  style='font-family:Courier'>arg(N,T,A)</span><span lang=EN-US> retrieves the </span><span
  lang=EN-US style='font-family:Courier'>N</span><span lang=EN-US>th argument </span><span
  lang=EN-US style='font-family:Courier'>A</span><span lang=EN-US>. However, </span><span
  lang=EN-US style='font-family:Courier'>arg/3</span><span lang=EN-US> requires
  </span><span lang=EN-US style='font-family:Courier'>N</span><span lang=EN-US>
  to be instantiated, and cannot be used to generate all arguments on
  backtracking. Therefore, lists are sometimes used even if the nature of the
  data is non-recursive. </span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>We use the above best-first search procedure,
with a number of changes. First, rather than returning the goal position found,
the program should construct a sequence of moves by which the goal position is
reached. Therefore, nodes that are examined during the search process are
collected in the list </span><span lang=EN-US style='font-family:Courier'>Visited</span><span
lang=EN-US>. After a goal position has been found, the solution path and its
total cost are reconstructed from the list </span><span lang=EN-US
style='font-family:Courier'>Visited</span><span lang=EN-US> by means of the
predicate </span><span lang=EN-US style='font-family:Courier'>construct_moves/6</span><span
lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>Secondly, the items on the agenda are
represented as pairs </span><span lang=EN-US style='font-family:Courier'>v(Value,Move)</span><span
lang=EN-US>, where </span><span lang=EN-US style='font-family:Courier'>Value</span><span
lang=EN-US> is the heuristic evaluation of the position reached by </span><span
lang=EN-US style='font-family:Courier'>Move</span><span lang=EN-US>. Children
of the current position are generated by means of the </span><span lang=EN-US
style='font-family:Courier'>setof/3</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;setof/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>predicate, which yields
a <b style='mso-bidi-font-weight:normal'>sorted</b> list. By putting the
heuristic </span><span lang=EN-US style='font-family:Courier'>Value</span><span
lang=EN-US> as the first argument of the functor </span><span lang=EN-US
style='font-family:Courier'>v</span><span lang=EN-US>, the list </span><span
lang=EN-US style='font-family:Courier'>Children</span><span lang=EN-US> is
therefore sorted according to increasing heuristic value. Therefore, this list
can be simply merged with the current agenda to yield the new agenda. The
program thus looks as follows: </span></p>

<p class=oms-eerst><span lang=EN-US>% tiles(M,C) &lt;- moves M lead to a goal
position at cost C <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(best-first search strategy)</span></p>

<p class=pi-laatst><span lang=EN-US>tiles</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;tiles/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Moves,Cost):-<br>
start(Start),<br>
eval(Start,Value),<br>
tiles_a([v(Value,Start)],Final,[],Visited),<br>
construct_moves(Final,Visited,[],Moves,0,Cost).</span></p>

<p class=pi><span lang=EN-US>% tiles_a(A,M,V0,V) &lt;- goal position can be
reached from </span></p>

<p class=pi><span lang=EN-US>%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>one of the positions on A with last </span></p>

<p class=pi><span lang=EN-US>%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>move M (best-first strategy)</span></p>

<p class=pi><span lang=EN-US>tiles_a([v(V,LastMove)|Rest],LastMove,Visited,Visited):-<br>
goal(LastMove).</span></p>

<p class=pi-laatst><span lang=EN-US>tiles_a([v(V,LastMove)|Rest],Goal,Visited0,Visited):-<br>
show_move(LastMove,V),<br>
setof0(v(Value,NextMove),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(
move(LastMove,NextMove),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>eval(NextMove,Value) ),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Children),<br>
merge(Children,Rest,NewAgenda),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>%
best-first<br>
tiles_a(NewAgenda,Goal,[LastMove|Visited0],Visited).</span></p>

<p class=pi-laatst><span lang=EN-US>%%% merge/3: see exercise 6.1</span></p>

<p class=tekst><span lang=EN-US style='font-family:Courier'>setof0/3</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;setof0/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is a variant of </span><span
lang=EN-US style='font-family:Courier'>setof/3</span><span lang=EN-US> which
succeeds with the empty list if no solutions can be found (see Appendix A.2). </span></p>

<p class=sektie><span lang=EN-US>A move from </span><span lang=EN-US
style='font-family:Courier'>OldPos</span><span lang=EN-US> to </span><span
lang=EN-US style='font-family:Courier'>NewPos</span><span lang=EN-US> is
represented by a triple </span></p>

<p class=p-el><span lang=EN-US>m(OldPos,NewPos,Cost)</span></p>

<p class=tekst><span lang=EN-US>where </span><span lang=EN-US style='font-family:
Courier'>Cost</span><span lang=EN-US> specifies the cost of the move. According
to the principle of data abstraction, this representation is kept local to the
following predicates: </span></p>

<p class=oms-eerst><span lang=EN-US>% move(m(X,P,Y),m(P,NP,C)) &lt;- position
NP can be reached <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>from position P in one move <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>at cost C</span></p>

<p class=pi-laatst><span lang=EN-US>move</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;move/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(m(OldPos,Pos,OldCost),m(Pos,NewPos,Cost)):-<br>
get_tile(Pos,Ne,e),get_tile(Pos,Nbw,BW),not(BW=e),<br>
Diff is abs(Ne-Nbw),Diff&lt;4,<br>
replace(Pos,Ne,BW,Pos1),<br>
replace(Pos1,Nbw,e,NewPos),<br>
( Diff=1<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span>-&gt; Cost=1<br>
; otherwise -&gt; Cost is Diff-1 ).</span></p>

<p class=pi-laatst><span lang=EN-US>start(m(noparent,[b,b,b,e,w,w,w],0)).</span></p>

<p class=oms><span lang=EN-US>% reconstruct total cost and path from visited
nodes</span></p>

<p class=pi><span lang=EN-US>construct_moves(m(noparent,Start,0),V,Ms,[Start|Ms],C,C).</span></p>

<p class=pi-laatst><span lang=EN-US>construct_moves(m(P,Pos,C),Visited,Ms0,Ms,C0,C):-<br>
element(m(GP,P,C1),Visited),<span style='mso-tab-count:1'>&nbsp; </span>% GP is
parent of P<br>
C1 is C0+C,<br>
construct_moves(m(GP,P,C1),Visited,[Pos|Ms0],Ms,C1,C).</span></p>

<p class=pi-laatst><span lang=EN-US>show_move(m(P,Pos,C),Value):-<br>
write(Pos-Value),nl.</span></p>

<p class=sektie><span lang=EN-US>Finally, we have to choose a heuristic
evaluation function. A first idea is to count, for each white tile, the number
of black tiles to the left of it:</span></p>

<p class=pi-el><span lang=EN-US>goal(LastMove):-<br>
eval(LastMove,0).</span></p>

<p class=pi-laatst><span lang=EN-US>eval</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;eval/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(m(P,Pos,C),Value):-<br>
bLeftOfw(Pos,Value).</span></p>

<p class=pi-laatst><span lang=EN-US>bLeftOfw(Pos,Value):-<br>
findall((Nb,Nw),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(get_tile(Pos,Nb,b),get_tile(Pos,Nw,w),Nb&lt;Nw),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>L),<br>
length(L,Value).</span></p>

<p class=tekst><span lang=EN-US>Note that this program actually <i
style='mso-bidi-font-style:normal'>counts</i> the number of solutions to the
query </span></p>

<p class=p-el><span lang=EN-US>?-get_tile(Pos,Nb,b),get_tile(Pos,Nw,w),Nb&lt;Nw.</span></p>

<p class=tekst><span lang=EN-US>by determining the length of the list that is
returned by the second-order predicate </span><span lang=EN-US
style='font-family:Courier'>findall/3</span><span lang=EN-US>.</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
6.2.</span></i><span lang=EN-US> Rewrite </span><span lang=EN-US
style='font-family:Courier'>bLeftOfw/2</span><span lang=EN-US> such that it
uses only first-order predicates.</span></p>

</div>

<p class=sektie><span lang=EN-US>The program writes every move it considers on
the screen, together with its heuristic evaluation. For instance, the query </span></p>

<p class=p-el><span lang=EN-US>?-tiles(M,C).</span></p>

<p class=tekst><span lang=EN-US>results in the following output:</span></p>

<p class=p-eerst style='mso-pagination:widow-orphan;page-break-after:auto'><span
lang=EN-US>[b,b,b,e,w,w,w]-9<br>
[b,b,b,w,e,w,w]-9<br>
[b,b,e,w,b,w,w]-8<br>
[b,b,w,w,b,e,w]-7<br>
[b,b,w,w,b,w,e]-7<br>
[b,b,w,w,e,w,b]-6<br>
[b,e,w,w,b,w,b]-4</span></p>

<p class=programma><span lang=EN-US>[b,w,e,w,b,w,b]-4<br>
[e,w,b,w,b,w,b]-3<br>
[w,w,b,e,b,w,b]-2<br>
[w,w,b,w,b,e,b]-1</span></p>

<p class=pi style='margin-left:48.0pt;text-indent:-31.0pt'><span lang=EN-US>M =
[[b,b,b,e,w,w,w],[b,b,b,w,e,w,w],[b,b,e,w,b,w,w],<br>
[b,b,w,w,b,e,w],[b,b,w,w,b,w,e],[b,b,w,w,e,w,b],<br>
[b,e,w,w,b,w,b],[b,w,e,w,b,w,b],[e,w,b,w,b,w,b],<br>
[w,w,b,e,b,w,b],[w,w,b,w,b,e,b],[w,w,e,w,b,b,b]]</span></p>

<p class=pi-laatst><span lang=EN-US>C = 15</span></p>

<p class=tekst><span lang=EN-US>Since the only moves that are considered are
those that are on the final solution path, there is no <a name=bk1>backtracking.
This seems to suggest that the heuristic works quite well. On the other hand,
the first few moves seem a bit awkward: in particular, the first and the fourth
move are relatively expensive.</a></span></p>

<p class=sektie><span style='mso-bookmark:bk1'><span lang=EN-US>Lets try
another heuristic, which counts the number of tiles out of place: a wrong tile
on the first or seventh square gives 3, on the second or sixth square 2, and on
the third or fifth square 1.</span></span></p>

<p class=pi-el><span style='mso-bookmark:bk1'><span lang=EN-US>eval</span></span><!--[if supportFields]><span
style='mso-bookmark:bk1'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk1'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;eval/2&quot;
</span></span><![endif]--><span style='mso-bookmark:bk1'></span><!--[if supportFields]><span
style='mso-bookmark:bk1'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk1'><span lang=EN-US>(Pos,Value):-<br>
outOfPlace(Pos,1,0,Value).</span></span></p>

<p class=pi><span style='mso-bookmark:bk1'><span lang=EN-US>outOfPlace(Pos,8,N,N).</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk1'><span lang=EN-US>outOfPlace(Pos,K,N0,N):-<br>
K&lt;8, K1 is K+1,<br>
( K&lt;4,get_tile(Pos,K,b) -&gt; N1 is N0-(K-4)<br>
; K&gt;4,get_tile(Pos,K,w) -&gt; N1 is N0+(K-4)<br>
; otherwise -&gt; N1=N0 ),<br>
outOfPlace(Pos,K1,N1,N).</span></span></p>

<p class=tekst><span style='mso-bookmark:bk1'><span lang=EN-US>We get the
following result: </span></span></p>

<p class=p-eerst style='mso-pagination:widow-orphan;page-break-after:auto'><span
style='mso-bookmark:bk1'><span lang=EN-US>[b,b,b,e,w,w,w]-12<br>
[b,b,b,w,w,w,e]-9<br>
[e,b,b,b,w,w,w]-9<br>
[b,b,b,w,w,e,w]-10<br>
[b,b,b,w,w,w,e]-9<br>
[b,b,e,w,w,b,w]-9<br>
[e,b,b,w,w,b,w]-7<br>
[w,b,b,e,w,b,w]-7<br>
[w,b,b,w,w,b,e]-4<br>
[w,b,b,w,w,e,b]-4<br>
[w,b,e,w,w,b,b]-3<br>
[w,b,w,w,e,b,b]-2</span></span></p>

<p class=pi style='margin-left:48.0pt;text-indent:-31.0pt'><span
style='mso-bookmark:bk1'><span lang=EN-US>M = [[b,b,b,e,w,w,w],[b,b,b,w,w,e,w],[b,b,e,w,w,b,w],<br>
[e,b,b,w,w,b,w],[w,b,b,e,w,b,w],[w,b,b,w,w,b,e],<br>
[w,b,b,w,w,e,b],[w,b,e,w,w,b,b],[w,b,w,w,e,b,b],<br>
[w,e,w,w,b,b,b]]</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk1'><span lang=EN-US>C = 14</span></span></p>

<p class=tekst><span style='mso-bookmark:bk1'><span lang=EN-US>We observe a
couple of differences with the previous heuristic. First of all, there is
backtracking</span></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;backtracking&quot;
\r &quot;bk1&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: the first, second and fourth moves are not pursued any further.
Furthermore, the solution found requires two moves less, and is also cheaper. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm'>
  <p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
   id="Picture_x0020_10" o:spid="_x0000_i1026" type="#_x0000_t75" style='width:370pt;
   height:342pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20II_files/image017.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=372 height=344
  src="Part%20II_files/image018.png" v:shapes="Picture_x0020_10"><![endif]></span></p>
  </div>
  <p class=Caption1><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  6.2.</span></b><span lang=EN-US> Solutions found for different heuristics.</span></p>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>This improvement seems to suggest that an
increased punishment for wrongly placed tiles might lead to an even cheaper
solution. For instance, we could increase the punishment to 4, 3 and 2,
respectively, by adapting the predicate </span><span lang=EN-US
style='font-family:Courier'>outOfPlace/4</span><span lang=EN-US> (try it!).
This leads to the following sequence of moves: </span></p>

<p class=p-eerst><span lang=EN-US>[b,b,b,e,w,w,w]-18<br>
[b,b,b,w,w,w,e]-14<br>
[e,b,b,b,w,w,w]-14<br>
[b,b,b,w,w,e,w]-15<br>
[b,b,e,w,w,b,w]-13<br>
[b,b,w,w,e,b,w]-11<br>
[b,e,w,w,b,b,w]-8<br>
[e,b,w,w,b,b,w]-7<br>
[w,b,e,w,b,b,w]-7<br>
[w,e,b,w,b,b,w]-6<br>
[e,w,b,w,b,b,w]-6<br>
[w,w,b,e,b,b,w]-6<br>
[w,w,b,w,b,b,e]-2<br>
[w,w,b,w,b,e,b]-2</span></p>

<p class=pi style='margin-left:48.0pt;text-indent:-31.0pt'><span lang=EN-US>M =
[[b,b,b,e,w,w,w],[b,b,b,w,w,e,w],[b,b,e,w,w,b,w],<br>
[b,b,w,w,e,b,w],[b,e,w,w,b,b,w],[e,b,w,w,b,b,w],<br>
[w,b,e,w,b,b,w],[w,e,b,w,b,b,w],[w,w,b,e,b,b,w],<br>
[w,w,b,w,b,b,e],[w,w,b,w,b,e,b],[w,w,e,w,b,b,b]]</span></p>

<p class=pi-laatst><span lang=EN-US>C = 15</span></p>

<p class=tekst><span lang=EN-US>Obviously, this heuristic works no better than
the previous two: it does not find an optimal solution, and it investigates
more moves than the first heuristic. In fig. 6.2, the solutions found by the
three heuristics are compared. In the next section, we will investigate the
conditions under which a heuristic</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;heuristic&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is guaranteed to find an
optimal solution. </span></p>

<h3><span lang=EN-US>6.2<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Optimal
best-first search</span></h3>

<p class=sektie1><span lang=EN-US>Best-first search is an exhaustive search</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;exhaustive
search&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>strategy, with a
possible behaviour ranging from depth-first search to breadth-first search,
depending on the heuristic used. By itself, best-first search is not complete:
the heuristic might consistently assign lower values to the nodes on an
infinite path.</span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;best-first
search:completeness&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>This is because the
heuristic evaluation only takes into account an estimate of the distance to a
goal, while we are actually interested in minimising the <b style='mso-bidi-font-weight:
normal'>total cost</b> of reaching a goal along a particular path. In order to
obtain a complete best-first search algorithm, we use an evaluation function <i
style='mso-bidi-font-style:normal'>f</i> consisting of two components:</span></p>

<p class=formule style='line-height:normal'><i style='mso-bidi-font-style:normal'><span
lang=EN-US>f</span></i><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>n</i>)
= <i style='mso-bidi-font-style:normal'>g</i>(<i style='mso-bidi-font-style:
normal'>n</i>) + <i style='mso-bidi-font-style:normal'>h</i>(<i
style='mso-bidi-font-style:normal'>n</i>)</span></p>

<p class=tekst><span lang=EN-US>Here, <i style='mso-bidi-font-style:normal'>h</i>(<i
style='mso-bidi-font-style:normal'>n</i>) is the heuristic estimate of the cost
of reaching a goal node from node <i style='mso-bidi-font-style:normal'>n</i>,
as it was introduced before. <i style='mso-bidi-font-style:normal'>g</i>(<i
style='mso-bidi-font-style:normal'>n</i>) is the actual cost of reaching <i
style='mso-bidi-font-style:normal'>n</i> from the starting node. Their sum <i
style='mso-bidi-font-style:normal'>f</i>(<i style='mso-bidi-font-style:normal'>n</i>)
is used to order the nodes on the agenda. </span></p>

<p class=sektie><span lang=EN-US>A best-first search algorithm which uses such
an evaluation function <i style='mso-bidi-font-style:normal'>f</i> to estimate
the total cost of a path is called an <i style='mso-bidi-font-style:normal'>A
algorithm</i></span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;A algorithm&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. An A algorithm</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;A
algorithm:completeness&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is complete, since the
depth count <i style='mso-bidi-font-style:normal'>g</i>(<i style='mso-bidi-font-style:
normal'>n</i>) will prevent search from getting trapped in an infinite path. In
effect, the depth count will give the search strategy more of a breadth-first
flavour. Indeed, breadth-first search is a special case of an A algorithm, with
<i style='mso-bidi-font-style:normal'>h</i>(<i style='mso-bidi-font-style:normal'>n</i>)=0
for every node <i style='mso-bidi-font-style:normal'>n</i>. A disadvantage of A
algorithms is the decreased efficiency</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;A
algorithm:efficiency&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>associated with this
breadth-first flavour. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
6.3.</span></i><span lang=EN-US> Change the </span><span lang=EN-US
style='font-family:Courier'>tiles</span><span lang=EN-US> program into an A
algorithm, by associating with each move the <i style='mso-bidi-font-style:
normal'>g</i>-value of the position reached by that move (i.e. the cost of the
path leading to that position, instead of the cost of the last move).
Demonstrate the decreased efficiency of the search. </span></p>

</div>

<p class=sektie><span lang=EN-US>Breadth-first search is not only complete, it
is also optimal: it always returns a shortest solution path</span><a
style='mso-footnote-id:ftn6' href="#_ftn6" name="_ftnref6" title=""><span
class=MsoFootnoteReference><span lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:
10.0pt'><span style='mso-special-character:footnote'><![if !supportFootnotes]><span
class=MsoFootnoteReference><span lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:
Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:
AR-SA'>[17]</span></span><![endif]></span></span></span></a><span lang=EN-US>.
Do A algorithms inherit this property from breadth-first search? Obviously,
this depends on the function <i style='mso-bidi-font-style:normal'>h</i>: if a
node <i style='mso-bidi-font-style:normal'>n</i></span><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>1</span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>on the cheapest path
gets an <i style='mso-bidi-font-style:normal'>h</i>-estimate that is too high,
other nodes will be tried instead, and a solution along a non-optimal path may
be found first. We say that the heuristic</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;heuristic:pessimistic&quot;
\b </span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>was too <i
style='mso-bidi-font-style:normal'>pessimistic</i> regarding <i
style='mso-bidi-font-style:normal'>n</i></span><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>1</span><span
lang=EN-US>. Conversely, a heuristic which never assigns a value to a node that
is higher than the actual cost of reaching a goal state from that node is
called <i style='mso-bidi-font-style:normal'>optimistic</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;heuristic:<i
style='mso-bidi-font-style:normal'>optimistic</i>&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>For instance, consider the first heuristic for
the puzzle in the previous section, which counts for each white tile the number
of black tiles to the left of it. Suppose one black tile has <i
style='mso-bidi-font-style:normal'>w</i> white tiles to its right, which adds <i
style='mso-bidi-font-style:normal'>w</i> to the heuristic value for that
position. In order to reach a goal position, the black tile has to jump over some
of the white tiles, while the remaining white tiles have to jump over the black
tile; this has a cost of at least <i style='mso-bidi-font-style:normal'>w</i>.
Therefore, this heuristic is optimistic. The second heuristic, calculating a
weighted sum of tiles out of place, is also optimistic. For instance, suppose
that a black tile is at the first square, then there are three white tiles to
its right, over which it must jump. Analogously, if it is on the second square,
then there are at least two white tiles to jump over. In contrast, the weights
used in the third heuristic are too high. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
6.4.</span></i><span lang=EN-US> Find a position for which the third heuristic
is too pessimistic.</span></p>

</div>

<p class=sektie><span lang=EN-US>It is possible to prove the following
important result: <i style='mso-bidi-font-style:normal'>an A algorithm with an
optimistic heuristic h always results in an optimal solution</i>. The resulting
algorithm is called <i style='mso-bidi-font-style:normal'>A*</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;A*</span></i><span lang=EN-US>
algorithm<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>(A star); both A* search
and optimistic heuristics are said to be <i style='mso-bidi-font-style:normal'>admissible</i>.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;heuristic:admissibility&quot;
\b </span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;A* algorithm:optimality&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>This should not be
mistaken to suggest that better heuristics are more optimistic! On the
contrary, a good heuristic is as pessimistic as possible, without becoming
non-admissible. In general, if <i style='mso-bidi-font-style:normal'>h</i></span><span
lang=EN-US style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:
-2.0pt'>1</span><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>n</i>)<i
style='mso-bidi-font-style:normal'>h</i></span><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>2</span><span
lang=EN-US>(<i style='mso-bidi-font-style:normal'>n</i>) for any node <i
style='mso-bidi-font-style:normal'>n</i>, then we call heuristic <i
style='mso-bidi-font-style:normal'>h</i></span><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>1</span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>at least as<i
style='mso-bidi-font-style:normal'> informed</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;heuristic:<i
style='mso-bidi-font-style:normal'>informed</i>ness&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>as <i style='mso-bidi-font-style:
normal'>h</i></span><span lang=EN-US style='font-size:9.0pt;position:relative;
top:2.0pt;mso-text-raise:-2.0pt'>2</span><span lang=EN-US>. It can be shown
that a more informed heuristic indeed searches a smaller part of the search
space. </span></p>

<p class=sektie><span lang=EN-US>As a small example, consider the search space
in fig. 6.3. The <i style='mso-bidi-font-style:normal'>h</i>-values for each
node are as indicated; the cost per arc is 1. The heuristic is optimistic, so
A* search will return the shortest path <i style='mso-bidi-font-style:normal'>start-r-s-goal</i>.
However, this path is not found immediately: since both <i style='mso-bidi-font-style:
normal'>p</i> and <i style='mso-bidi-font-style:normal'>q</i> have a lower <i
style='mso-bidi-font-style:normal'>f</i>-value than <i style='mso-bidi-font-style:
normal'>r</i>, they are investigated first. After <i style='mso-bidi-font-style:
normal'>q</i> has been investigated, <i style='mso-bidi-font-style:normal'>s</i>
is put on the agenda with <i style='mso-bidi-font-style:normal'>f</i>-value
3+1=4. Since <i style='mso-bidi-font-style:normal'>r</i> has a lower <i
style='mso-bidi-font-style:normal'>f</i>-value of 3, it is the next one to be
investigated. Now <i style='mso-bidi-font-style:normal'>s</i> will again be
added to the agenda, this time with <i style='mso-bidi-font-style:normal'>f</i>-value
2+1=3! In fact, it is this latter <i style='mso-bidi-font-style:normal'>s</i>
which, being on the optimal path, leads to the goal. </span></p>

<p class=sektie><span lang=EN-US>Thus, although admissible search leads to
optimal solutions, it is not necessarily the case that every node on an optimal
path is immediately reached along that optimal path. In fig. 6.3, this is
caused by local pessimism of the heuristic, which estimates the cost of
moving from <i style='mso-bidi-font-style:normal'>start</i> to <i
style='mso-bidi-font-style:normal'>p</i> as 3&#8211;1=2, while the actual cost
is 1. Indeed, if <i style='mso-bidi-font-style:normal'>p</i> would have an <i
style='mso-bidi-font-style:normal'>h</i>-value of 2, <i style='mso-bidi-font-style:
normal'>s</i> would have been reached the first time along the shortest path.
This is true in general: if the heuristic estimates the cost of moving from one
node to another optimistically, then any node is reached along the cheapest
path first. This property is called <i style='mso-bidi-font-style:normal'>monotonicity</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;heuristic:<i
style='mso-bidi-font-style:normal'>monotonicity</i>&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, since one can show that the <i style='mso-bidi-font-style:normal'>f</i>-values
are monotonically non-decreasing along a path. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=med-figure style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm'><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
   id="Picture_x0020_11" o:spid="_x0000_i1025" type="#_x0000_t75" style='width:117pt;
   height:150pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20II_files/image019.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=119 height=152
  src="Part%20II_files/image020.png" v:shapes="Picture_x0020_11"><![endif]></span></p>
  </div>
  <p class=med-caption><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  6.3</span></b><span lang=EN-US>. A heuristic which is not monotonic.</span></p>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>The first heuristic of the previous section is
monotonic, while the second is not. This can be concluded from the following
two evaluations: </span></p>

<p class=p-el><span lang=EN-US>[b,b,e,w,w,b,w]-9<br>
[e,b,b,w,w,b,w]-7</span></p>

<p class=tekst><span lang=EN-US>The heuristic estimates the cost of this move
as 9&#8211;7=2, while the actual cost is 1. Since monotonicity implies
admissibility, the third heuristic is not monotonic either. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
6.5.</span></i><span lang=EN-US> Implement a Prolog meta-interpreter which
employs an A search algorithm. Use <i style='mso-bidi-font-style:normal'>h</i>(<i
style='mso-bidi-font-style:normal'>R</i>)= |<i style='mso-bidi-font-style:normal'>R</i>|
(the number of literals in resolvent <i style='mso-bidi-font-style:normal'>R</i>)
as heuristic. Is this heuristic admissible and monotonic? </span></p>

</div>

<h3><span lang=EN-US>6.3<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Non-exhaustive
informed search</span></h3>

<p class=sektie1><span lang=EN-US>The search strategies discussed until now are
all <i style='mso-bidi-font-style:normal'>exhaustive</i>: they will all search
the complete search space in the worst case. This is so because <b
style='mso-bidi-font-weight:normal'>all</b> children of a certain node will be
put on the agenda, in some order. Exhaustive search</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Exhaustive
search:size of the agenda&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is often impractical,
since the size of the agenda grows exponentially with the search depth. The use
of a heuristic offers the possibility of keeping only a selection of best nodes
on the agenda. Such non-exhaustive search strategies are, of course, not
guaranteed to be complete, and should only be applied in combination with a
reasonably informed heuristic. </span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;heuristic:informedness&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=sektie><i style='mso-bidi-font-style:normal'><span lang=EN-US>Beam
search</span></i><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Beam search&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is a form of best-first
search in which the number of nodes on the agenda is limited. In its most
simple form, the agenda is of fixed size. Alternatively, one could allow the
agenda to grow polynomially (instead of exponentially) with the search depth.
The effect of this strategy is, that only a beam of the search space is
searched: </span></p>

<p class=pi-el><span lang=EN-US>search_beam</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search_beam/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Agenda,Goal):-<br>
search_beam(1,Agenda,[],Goal).</span></p>

<p class=pi><span lang=EN-US>search_beam(D,[],NextLayer,Goal):-<br>
D1 is D+1,<br>
search_beam(D1,NextLayer,[],Goal).</span></p>

<p class=pi><span lang=EN-US>search_beam(D,[Goal|Rest],NextLayer,Goal):-<br>
goal(Goal).</span></p>

<p class=pi-laatst><span lang=EN-US>search_beam(D,[Current|Rest],NextLayer,Goal):-<br>
children(Current,Children),<br>
add_beam(D,Children,NextLayer,NewNextLayer),<br>
search_beam(D,Rest,NewNextLayer,Goal).</span></p>

<p class=tekst><span lang=EN-US>In this program, two agendas are maintained,
one for the current level, and one for the children of the nodes on the current
level. Once the current level is exhausted, the agendas are swapped and the
depth count is increased. The depth count is passed on to the predicate </span><span
lang=EN-US style='font-family:Courier'>add_beam/4</span><span lang=EN-US>, in
order to decide how many children to add to the agenda for the next level. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
6.6.</span></i><span lang=EN-US> Extend the program of exercise 6.3 with beam
search with fixed agenda size. Demonstrate the non-optimality of the search
strategy. </span></p>

</div>

<p class=sektie><span lang=EN-US>If we limit the size of the agenda to 1, we
arrive at a search strategy called <i style='mso-bidi-font-style:normal'>hill-climbing</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;hill-climbing&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. It is also callled <i style='mso-bidi-font-style:normal'>greedy</i>
search</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;greedy</span></i><span lang=EN-US>
search<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, since there is no backtracking </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;backtracking &quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>involved. Hill-climbing is the type of search employed by a wanderer
who wants to reach the top of a hill by always moving in the steepest
direction. Clearly, she will reach the top of a hill (and never get off it),
but it is not necessarily the highest one. </span></p>

<p class=sektie><span lang=EN-US>The predicate </span><span lang=EN-US
style='font-family:Courier'>search_hc/2</span><span lang=EN-US> below
implements a hill-climbing search strategy. Instead of maintaining an agenda of
nodes yet to be investigated, it maintains a single node in its first argument.
Therefore, hill-climbing has some similarity with depth-first search with
implicit agenda: </span></p>

<p class=pi-eerst><span lang=EN-US>search_hc</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search_hc/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Goal,Goal):-<br>
goal(Goal).</span></p>

<p class=pi-laatst><span lang=EN-US>search_hc(Current,Goal):-<br>
children(Current,Children),<br>
select_best(Children,Best),<br>
search_hc(Best,Goal).</span></p>

<p class=tekst><span lang=EN-US>The predicate </span><span lang=EN-US
style='font-family:Courier'>select_best/2</span><span lang=EN-US> selects the
best child of the current node, according to the heuristic value to be
optimised. To stress that backtracking is not needed after the best child has been
selected, one can place a cut before the recursive call in the second clause. </span></p>

<h3><span lang=EN-US>Further reading</span></h3>

<p class=sektie1><span lang=EN-US>Nilsson (1980) gives a gentle introduction to
the use of heuristics and their properties. (Pearl, 1984) is the main source
for mathematical results on heuristics. The sliding tiles puzzle</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;sliding
tiles puzzle&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>was taken from (Luger
&amp; Stubblefield, 1993). </span></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>G.F.
Luger &amp; W.A. Stubblefield (</span><span lang=EN-US>1993)<span
style='font-variant:small-caps'>,</span> <i style='mso-bidi-font-style:normal'>Artificial
Intelligence: Structures and Strategies for Complex Problem Solving</i>,
Benjamin/Cummings, second edition.<span style='display:none;mso-hide:all'>.F.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Luger,
G.F.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.A.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Stubblefield,
W.A.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>N.J.
Nilsson (</span><span lang=EN-US>1980)<span style='font-variant:small-caps'>,</span>
<i style='mso-bidi-font-style:normal'>Principles of Artificial Intelligence</i>,
Tioga Press.<span style='display:none;mso-hide:all'>.J.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Nilsson,
N.J.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>J. Pearl</span><span
lang=EN-US> (1984), <i style='mso-bidi-font-style:normal'>Heuristics:
Intelligent Search Strategies for Computer Problem Solving</i>, Addison-Wesley.<span
style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Pearl,
J.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

</div>

<div style='mso-element:footnote-list'><![if !supportFootnotes]><br clear=all>

<hr align=left size=1 width="33%">

<![endif]>

<div style='mso-element:footnote' id=ftn1>

<p class=MsoFootnoteText><a style='mso-footnote-id:ftn1' href="#_ftnref1"
name="_ftn1" title=""><span class=MsoFootnoteReference><span lang=EN-US
style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span style='mso-special-character:
footnote'><![if !supportFootnotes]><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:Times;
mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA'>[12]</span></span><![endif]></span></span></span></a><span
lang=EN-US>The remaining disk on A can safely be ignored, since it is the
largest.</span></p>

</div>

<div style='mso-element:footnote' id=ftn2>

<p class=MsoFootnoteText><a style='mso-footnote-id:ftn2' href="#_ftnref2"
name="_ftn2" title=""><span class=MsoFootnoteReference><span lang=EN-US
style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span style='mso-special-character:
footnote'><![if !supportFootnotes]><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:Times;
mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA'>[13]</span></span><![endif]></span></span></span></a><span
lang=EN-US>Such a program should perform breadth-first search; see Exercise
5.2.</span></p>

</div>

<div style='mso-element:footnote' id=ftn3>

<p class=MsoFootnoteText><a style='mso-footnote-id:ftn3' href="#_ftnref3"
name="_ftn3" title=""><span class=MsoFootnoteReference><span lang=EN-US
style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span style='mso-special-character:
footnote'><![if !supportFootnotes]><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:Times;
mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA'>[14]</span></span><![endif]></span></span></span></a><span
lang=EN-US>From now on, we denote a </span><span lang=EN-US style='font-family:
Courier'>Predicate</span><span lang=EN-US> with </span><span lang=EN-US
style='font-family:Courier'>Arity</span><span lang=EN-US> as </span><span
lang=EN-US style='font-family:Courier'>Predicate/Arity</span><span lang=EN-US>.
This is because predicates with different arity are different predicates, even
if they share the same predicate name.</span></p>

</div>

<div style='mso-element:footnote' id=ftn4>

<p class=MsoFootnoteText><a style='mso-footnote-id:ftn4' href="#_ftnref4"
name="_ftn4" title=""><span class=MsoFootnoteReference><span lang=EN-US
style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span style='mso-special-character:
footnote'><![if !supportFootnotes]><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:Times;
mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA'>[15]</span></span><![endif]></span></span></span></a><span
lang=EN-US>Here, we refer to the resultant path, ignoring backtracking.</span></p>

</div>

<div style='mso-element:footnote' id=ftn5>

<p class=MsoFootnoteText><a style='mso-footnote-id:ftn5' href="#_ftnref5"
name="_ftn5" title=""><span class=MsoFootnoteReference><span lang=EN-US
style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span style='mso-special-character:
footnote'><![if !supportFootnotes]><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:Times;
mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA'>[16]</span></span><![endif]></span></span></span></a><span
lang=EN-US>We will assume for the moment that the head literals are ground by
the substitution which makes the body true; a more detailed discussion follows
below.</span></p>

</div>

<div style='mso-element:footnote' id=ftn6>

<p class=MsoFootnoteText><a style='mso-footnote-id:ftn6' href="#_ftnref6"
name="_ftn6" title=""><span class=MsoFootnoteReference><span lang=EN-US
style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span style='mso-special-character:
footnote'><![if !supportFootnotes]><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:Times;
mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA'>[17]</span></span><![endif]></span></span></span></a><span
lang=EN-US>If arcs can have different costs, breadth-first search does not
necessarily return the <b style='mso-bidi-font-weight:normal'>cheapest</b>
solution path. </span></p>

</div>

</div>
<script>$(function() { $(".swish").LPN({swish:"http://swish.swi-prolog.org/"}); });</script>
</body>

</html>

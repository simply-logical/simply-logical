
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>8.3. Abduction and diagnostic reasoning &#8212; Simply Logical</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-prolog.css?v=c1617293" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jquery-ui.min.css?v=711a7f8d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/lpn.css?v=a05dc249" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sl.css?v=3011a09a" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=a6b63e94"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script src="../../../_static/jquery.js?v=3d1d8b85"></script>
    <script src="../../../_static/jquery-ui.min.js?v=27a1b71a"></script>
    <script src="../../../_static/lpn.js?v=199b1815"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-JFZBHCMB8V"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-JFZBHCMB8V');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-JFZBHCMB8V');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'src/text/3_part_iii/8.3';</script>
    <link rel="icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="8.4. The complete picture" href="8.4.html" />
    <link rel="prev" title="8.2. The semantics of incomplete information" href="8.2.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../simply-logical.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/SL.svg" class="logo__image only-light" alt=""/>
    <img src="../../../_static/SL.svg" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">Simply Logical</p>
  
</a></div>
        <div class="sidebar-primary-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/simply-logical/simply-logical/blob/master/LICENCE" title="Licence" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="https://img.shields.io/badge/Licence-CC%20BY--NC--SA%204.0-lightgrey.svg" class="icon-link-image" alt="Licence"/></a>
        </li>
</ul></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../simply-logical.html">
                    Simply Logical
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../0_preface/_preface.html">Preface</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../1_part_i/_part_i.html">I. Logic and Logic Programming</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../1_part_i/1.0.html">1. A brief introduction to clausal logic</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/1.1.html">1.1. Answering queries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/1.2.html">1.2. Recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/1.3.html">1.3. Structured terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/1.4.html">1.4. What else is there to know about clausal logic?</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../1_part_i/2.0.html">2. Clausal logic and resolution: theoretical backgrounds</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.1.html">2.1. Propositional clausal logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.2.html">2.2. Relational clausal logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.3.html">2.3. Full clausal logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.4.html">2.4. Definite clause logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.5.html">2.5. The relation between clausal logic and Predicate Logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.6.html">2.6. Further reading</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../1_part_i/3.0.html">3. Logic Programming and Prolog</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.1.html">3.1. SLD-resolution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.2.html">3.2. Pruning the search by means of cut</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.3.html">3.3. Negation as failure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.4.html">3.4. Other uses of cut</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.5.html">3.5. Arithmetic expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.6.html">3.6. Accumulators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.7.html">3.7. Second-order predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.8.html">3.8. Meta-programs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.9.html">3.9. A methodology of Prolog programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.10.html">3.10. Further reading</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../2_part_ii/_part_ii.html">II. Reasoning with structured knowledge</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../2_part_ii/4.0.html">4. Representing structured knowledge</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/4.1.html">4.1. Trees as terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/4.2.html">4.2. Graphs generated by a predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/4.3.html">4.3. Inheritance hierarchies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/4.4.html">4.4. Further reading</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../2_part_ii/5.0.html">5. Searching graphs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/5.1.html">5.1. A general search procedure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/5.2.html">5.2. Depth-first search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/5.3.html">5.3. Breadth-first search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/5.4.html">5.4. Forward chaining</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/5.5.html">5.5. Further reading</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../2_part_ii/6.0.html">6. Informed search</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/6.1.html">6.1. Best-first search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/6.2.html">6.2. Optimal best-first search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/6.3.html">6.3. Non-exhaustive informed search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2_part_ii/6.4.html">6.4. Further reading</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="_part_iii.html">III. Advanced reasoning techniques</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2 has-children"><a class="reference internal" href="7.0.html">7. Reasoning with natural language</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="7.1.html">7.1. Grammars and parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="7.2.html">7.2. Definite Clause Grammars</a></li>
<li class="toctree-l3"><a class="reference internal" href="7.3.html">7.3. Interpretation of natural language</a></li>
<li class="toctree-l3"><a class="reference internal" href="7.4.html">7.4. Further reading</a></li>
</ul>
</details></li>
<li class="toctree-l2 current active has-children"><a class="reference internal" href="8.0.html">8. Reasoning with incomplete information</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="8.1.html">8.1. Default reasoning</a></li>
<li class="toctree-l3"><a class="reference internal" href="8.2.html">8.2. The semantics of incomplete information</a></li>
<li class="toctree-l3 current active"><a class="current reference internal" href="#">8.3. Abduction and diagnostic reasoning</a></li>
<li class="toctree-l3"><a class="reference internal" href="8.4.html">8.4. The complete picture</a></li>
<li class="toctree-l3"><a class="reference internal" href="8.5.html">8.5. Further reading</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="9.0.html">9. Inductive reasoning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="9.1.html">9.1. Generalisation and specialisation</a></li>
<li class="toctree-l3"><a class="reference internal" href="9.2.html">9.2. Bottom-up induction</a></li>
<li class="toctree-l3"><a class="reference internal" href="9.3.html">9.3. Top-down induction</a></li>
<li class="toctree-l3"><a class="reference internal" href="9.4.html">9.4. Further reading</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../appendices/_appendices.html">Additional materials</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../appendices/a_0.html">10. A catalogue of useful predicates</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../appendices/a_1.html">10.1. Built-in predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/a_2.html">10.2. A library of utility predicates</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../appendices/b_0.html">11. Two programs for logical conversion</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../appendices/b_1.html">11.1. From Predicate Logic to clausal logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/b_2.html">11.2. Predicate Completion</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../appendices/c_0.html">12. Answers to selected exercises</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_1.html">12.1. A brief introduction to clausal logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_2.html">12.2. Clausal logic and resolution: theoretical backgrounds</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_3.html">12.3. Logic Programming and Prolog</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_4.html">12.4. Representing structured knowledge</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_5.html">12.5. Searching graphs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_6.html">12.6. Informed search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_7.html">12.7. Reasoning with natural language</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_8.html">12.8. Reasoning with incomplete information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_9.html">12.9. Inductive reasoning</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference external" href="https://simply-logical.space/">Simply Logical Organisation</a></li>
<li class="toctree-l1"><a class="reference external" href="http://people.cs.bris.ac.uk/~flach/SimplyLogical.html">Original Book Home</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/simply-logical/simply-logical" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/simply-logical/simply-logical/edit/master/src/text/3_part_iii/8.3.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/simply-logical/simply-logical/issues/new?title=Issue%20on%20page%20%2Fsrc/text/3_part_iii/8.3.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/src/text/3_part_iii/8.3.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Abduction and diagnostic reasoning</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <!--H3: Section 8.3-->
<section class="tex2jax_ignore mathjax_ignore" id="abduction-and-diagnostic-reasoning">
<span id="sec-8-3"></span><h1><span class="section-number">8.3. </span>Abduction and diagnostic reasoning<a class="headerlink" href="#abduction-and-diagnostic-reasoning" title="Link to this heading">#</a></h1>
<p>Abduction extends default reasoning by not only making assumptions about what is false, but also about what is true. For instance, in the light bulb example given earlier, we know that if the light bulb is broken, the light doesn’t switch on. If we observe that the light doesn’t switch on, a possible explanation is that the light bulb is broken. Since this is only one of the possible explanations, it cannot be guaranteed to be true. For instance, there might be a problem with the power supply instead, or the switch might be broken.</p>
<p>The general problem of abduction can be stated as follows. Given a <span class="math notranslate nohighlight">\(Theory\)</span> and an <span class="math notranslate nohighlight">\(Observation\)</span>, find an <span class="math notranslate nohighlight">\(Explanation\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
Theory \cup Explanation \models Observation
\]</div>
<p>i.e. the <span class="math notranslate nohighlight">\(Observation\)</span> follows logically from the <span class="math notranslate nohighlight">\(Theory\)</span> extended with the <span class="math notranslate nohighlight">\(Explanation\)</span>. For instance, if <span class="math notranslate nohighlight">\(Theory\)</span> consists of the following clauses</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">likes</span><span class="p">(</span><span class="s s-Atom">peter</span><span class="p">,</span><span class="nv">S</span><span class="p">):-</span><span class="nf">student_of</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span><span class="s s-Atom">peter</span><span class="p">).</span>
<span class="nf">likes</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">):-</span><span class="nf">friend</span><span class="p">(</span><span class="nv">Y</span><span class="p">,</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>and we have the <span class="math notranslate nohighlight">\(Observation\)</span> <code class="docutils literal notranslate"><span class="pre">likes(peter,paul)</span></code>, then possible <span class="math notranslate nohighlight">\(Explanations\)</span> are <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">student_of(paul,peter)</span> <span class="pre">}</span></code> and <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">friend(paul,peter)</span> <span class="pre">}</span></code>.</p>
<p>Other <span class="math notranslate nohighlight">\(Explanations\)</span> which satisfy the problem specification are <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">likes(X,paul)</span> <span class="pre">}</span></code> and <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">likes(X,Y):-friendly(Y),</span> <span class="pre">friendly(paul)</span> <span class="pre">}</span></code>. However, abductive explanations are usually restricted to ground literals with predicates that are undefined in <span class="math notranslate nohighlight">\(Theory\)</span> (such literals are called <em>abducibles</em>). Inferring general rules from specific observations is called induction, and is discussed in the next chapter.</p>
<p>Procedurally, we can construct an abductive explanation by trying to prove the <span class="math notranslate nohighlight">\(Observation\)</span> from the initial <span class="math notranslate nohighlight">\(Theory\)</span> alone: whenever we encounter a literal for which there is no clause to resolve with, we add the literal to the <span class="math notranslate nohighlight">\(Explanation\)</span>. This leads to the following abductive meta-interpreter.</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-8-3-1">
<pre class="literal-block source swish" id="swish-8-3-1-code" source-text-end="
element(X,[X|_Ys]).
element(X,[_Y|Ys]):-
    element(X,Ys).

cl(likes(peter,S),student_of(S,peter)).
cl(likes(X,Y),friend(Y,X)).

cl(flies(X),(bird(X),not(abnormal(X)))).
cl(abnormal(X),penguin(X)).
cl(abnormal(X),dead(X)).
cl(bird(X),penguin(X)).
cl(bird(X),sparrow(X))." source-text-start=":-op(900,fy,not).

">
<span></span><span class="c1">% abduce(O,E) &lt;- observation O follows by SLD-resolution</span>
<span class="c1">%                from the theory defined by clause/2,</span>
<span class="c1">%                extended with a list of unit clauses E</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">O</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">O</span><span class="p">,[],</span><span class="nv">E</span><span class="p">).</span>

<span class="c1">% with accumulator for explanations</span>
<span class="nf">abduce</span><span class="p">(</span><span class="s s-Atom">true</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-!.</span>
<span class="nf">abduce</span><span class="p">((</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-!,</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E1</span><span class="p">),</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E1</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">cl</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span>  <span class="c1">% query clauses enumerated by cl/2</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">element</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,[</span><span class="nv">A</span><span class="p">|</span><span class="nv">E</span><span class="p">]):-</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">),</span>
    <span class="nf">abducible</span><span class="p">(</span><span class="nv">A</span><span class="p">).</span>

<span class="nf">abducible</span><span class="p">(</span><span class="nv">A</span><span class="p">):-</span>
    <span class="o">not</span> <span class="nf">cl</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="k">_</span><span class="nv">B</span><span class="p">).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?- abduce(likes(peter,paul),Explanation).</span>
<span class="cm">?- abduce(flies(tweety),Explanation).</span>
<span class="cm">*/</span></div>
</pre></div>
<p>The last two clauses of <code class="docutils literal notranslate"><span class="pre">abduce/3</span></code> extend the original depth-first meta-interpreter. The program uses an accumulator containing the partial explanation found so far, such that literals are not unnecessarily duplicated in the final explanation. The query</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="nf">likes</span><span class="p">(</span><span class="s s-Atom">peter</span><span class="p">,</span><span class="s s-Atom">paul</span><span class="p">),</span><span class="nv">Explanation</span><span class="p">).</span>
</pre></div>
</div>
<p>results in the answers</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Explanation</span> <span class="o">=</span> <span class="p">[</span><span class="nf">student_of</span><span class="p">(</span><span class="s s-Atom">paul</span><span class="p">,</span><span class="s s-Atom">peter</span><span class="p">)];</span>
<span class="nv">Explanation</span> <span class="o">=</span> <span class="p">[</span><span class="nf">friend</span><span class="p">(</span><span class="s s-Atom">paul</span><span class="p">,</span><span class="s s-Atom">peter</span><span class="p">)]</span>
</pre></div>
</div>
<p>Interestingly, this abductive meta-interpreter also works for general clauses, but it does not always produce correct explanations. For instance, suppose the initial <span class="math notranslate nohighlight">\(Theory\)</span> contains a general clause:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">flies</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="o">not</span> <span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="nf">penguin</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="nf">penguin</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="nf">sparrow</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>If asked to explain <code class="docutils literal notranslate"><span class="pre">flies(tweety)</span></code>, the above program will try to find a clause explaining <code class="docutils literal notranslate"><span class="pre">not(abnormal(tweety))</span></code>; since there is no such clause, this negated literal will be added to the explanation. As a result, the program will give the following explanations:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Explanation</span> <span class="o">=</span> <span class="p">[</span><span class="o">not</span> <span class="nf">abnormal</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nf">penguin</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)];</span>
<span class="nv">Explanation</span> <span class="o">=</span> <span class="p">[</span><span class="o">not</span> <span class="nf">abnormal</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nf">sparrow</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)]</span>
</pre></div>
</div>
<p>There are two problems with these explanations. First of all, the first explanation is inconsistent with the theory. Secondly, <code class="docutils literal notranslate"><span class="pre">abnormal/1</span></code> is not an abducible predicate, and should not appear in an abductive explanation. For these reasons, we have to deal explicitly with negated literals in our abduction program.</p>
<!--section 3.8-->
<p>As a first try, we can extend our abductive meta-interpreter with negation as failure, by adding the following clause (see also <a class="reference internal" href="../1_part_i/3.8.html#sec-3-8"><span class="std std-numref">Section 3.8</span></a>):</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">abduce</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>    <span class="c1">% E explains not(A)</span>
    <span class="o">not</span> <span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>  <span class="c1">% if E doesn&#39;t explain A</span>
</pre></div>
</div>
<p>In order to prevent the query <code class="docutils literal notranslate"><span class="pre">abducible(not(A))</span></code> from succeeding, we change the definition of <code class="docutils literal notranslate"><span class="pre">abducible/1</span></code> to</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-8-3-1-2">
<pre class="literal-block source swish" id="swish-8-3-1-2-code" source-text-end="
element(X,[X|_Ys]).
element(X,[_Y|Ys]):-
    element(X,Ys).

cl(likes(peter,S),student_of(S,peter)).
cl(likes(X,Y),friend(Y,X)).

cl(flies(X),(bird(X),not(abnormal(X)))).
cl(abnormal(X),penguin(X)).
cl(abnormal(X),dead(X)).
cl(bird(X),penguin(X)).
cl(bird(X),sparrow(X))." source-text-start=":-op(900,fy,not).

% abduce(O,E) &lt;- observation O follows by SLD-resolution
%                from the theory defined by clause/2,
%                extended with a list of unit clauses E
abduce(O,E) :-
    abduce(O,[],E).

% with accumulator for explanations
abduce(true,E,E):-!.
abduce((A,B),E0,E):-!,
    abduce(A,E0,E1),
    abduce(B,E1,E).
abduce(A,E0,E):-
    cl(A,B),  % query clauses enumerated by cl/2
    abduce(B,E0,E).
abduce(A,E,E):-
    element(A,E).
abduce(A,E,[A|E]):-
    not element(A,E),
    abducible(A).
abduce(not(A),E,E):-    % E explains not(A)
    not abduce(A,E,E).  % if E doesn't explain A

:- discontiguous cl/2.
cl(flies1(X),(not(abnormal(X),bird(X)))).

">
<span></span><span class="nf">abducible</span><span class="p">(</span><span class="nv">A</span><span class="p">):-</span>
    <span class="nv">A</span> <span class="s s-Atom">\=</span> <span class="o">not</span><span class="p">(</span><span class="nv">B</span><span class="p">),</span>
    <span class="o">not</span> <span class="nf">cl</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?- abduce(flies(tweety),Explanation).</span>
<span class="cm">?- abduce(not(abnormal(tweety)),[penguin(tweety)],[penguin(tweety)]).</span>
<span class="cm">?- abduce(not(abnormal(tweety)),[],[]).</span>
<span class="cm">?- abduce(flies1(tweety),Explanation).</span>
<span class="cm">*/</span></div>
</pre></div>
<p>With this extended abductive meta-interpreter, the query</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="nf">flies</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nv">Explanation</span><span class="p">).</span>
</pre></div>
</div>
<p>now results in the following, correct answer:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Explanation</span> <span class="o">=</span> <span class="p">[</span><span class="nf">sparrow</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)]</span>
</pre></div>
</div>
<p>The explanation <code class="docutils literal notranslate"><span class="pre">[penguin(tweety)]</span></code> is found to be inconsistent, since</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)),</span>
         <span class="p">[</span><span class="nf">penguin</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)],[</span><span class="nf">penguin</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)]).</span>
</pre></div>
</div>
<p>will fail, as it should.</p>
<p>However, this approach relies on the fact that negated literals are checked <strong>after</strong> the abductive explanation has been constructed. To illustrate this, suppose that <span class="math notranslate nohighlight">\(Theory\)</span> is extended with the following clause:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">flies1</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="o">not</span> <span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>Since</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)),[],[]).</span>
</pre></div>
</div>
<p>succeeds, any explanation of <code class="docutils literal notranslate"><span class="pre">bird(tweety)</span></code> will also be an explanation of <code class="docutils literal notranslate"><span class="pre">flies1(tweety)</span></code>, which is of course wrong. The problem here is that the fact that <code class="docutils literal notranslate"><span class="pre">abnormal(tweety)</span></code> is considered to be <strong>false</strong> is not reflected in the explanation. Thus, we need a separate predicate <code class="docutils literal notranslate"><span class="pre">abduce_not/3</span></code> for building explanations for literals assumed to be false.</p>
<p>The full program is given below. There are two changes in <code class="docutils literal notranslate"><span class="pre">abduce/3</span></code>: in the fifth clause, an abducible <code class="docutils literal notranslate"><span class="pre">A</span></code> is only added to the explanation <code class="docutils literal notranslate"><span class="pre">E</span></code> if it is consistent with it; i.e. if <code class="docutils literal notranslate"><span class="pre">E</span></code> does not explain <code class="docutils literal notranslate"><span class="pre">not(A)</span></code>. In the sixth clause, an explicit explanation for <code class="docutils literal notranslate"><span class="pre">not(A)</span></code> is constructed.</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% abduce(O,E0,E) &lt;- E is abductive explanation of O, given</span>
<span class="c1">%                   E0 (works also for general programs)</span>
<span class="nf">abduce</span><span class="p">(</span><span class="s s-Atom">true</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-!.</span>
<span class="nf">abduce</span><span class="p">((</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-!,</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E1</span><span class="p">),</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E1</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">clause</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">element</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>           <span class="c1">% already assumed</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,[</span><span class="nv">A</span><span class="p">|</span><span class="nv">E</span><span class="p">]):-</span>         <span class="c1">% A can be added to E</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">),</span>       <span class="c1">% if it&#39;s not already there,</span>
    <span class="nf">abducible</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>           <span class="c1">% if it&#39;s abducible,</span>
    <span class="o">not</span> <span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>  <span class="c1">% and E doesn&#39;t explain not(A)</span>
<span class="nf">abduce</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>       <span class="c1">% find explanation for not(A)</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">),</span>      <span class="c1">% should be consistent</span>
    <span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
</pre></div>
</div>
<p>The definition of <code class="docutils literal notranslate"><span class="pre">abduce_not/3</span></code> closely mirrors the clauses for <code class="docutils literal notranslate"><span class="pre">abduce/3</span></code>:</p>
<!--roman list-->
<ol class="arabic simple">
<li><p>a negated conjunction <code class="docutils literal notranslate"><span class="pre">not((A,B))</span></code> is explained by either explaining <code class="docutils literal notranslate"><span class="pre">not(A)</span></code> <strong>or</strong> <code class="docutils literal notranslate"><span class="pre">not(B)</span></code>;</p></li>
<li><p>if there are clauses for <code class="docutils literal notranslate"><span class="pre">A</span></code>, then <code class="docutils literal notranslate"><span class="pre">not(A)</span></code> is explained by constructing an explanation for <code class="docutils literal notranslate"><span class="pre">not(B)</span></code>, for <strong>every</strong> body <code class="docutils literal notranslate"><span class="pre">B</span></code>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">not(A)</span></code> is explained if it is already part of the explanation;</p></li>
<li><p>otherwise, <code class="docutils literal notranslate"><span class="pre">not(A)</span></code> is explained by itself, if <code class="docutils literal notranslate"><span class="pre">A</span></code> is abducible and not explained;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">not(not(A))</span></code> is explained by explaining <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p></li>
</ol>
<p>There is no clause for <code class="docutils literal notranslate"><span class="pre">true</span></code>, since <code class="docutils literal notranslate"><span class="pre">not(true)</span></code> cannot be explained.</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% abduce_not(O,E0,E) &lt;- E is abductive expl. of not(O)</span>
<span class="nf">abduce_not</span><span class="p">((</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-!,</span>
    <span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">);</span>       <span class="c1">% disjunction</span>
    <span class="nf">abduce_not</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">setof</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nf">clause</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span><span class="nv">L</span><span class="p">),</span>
    <span class="nf">abduce_not_l</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">element</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E</span><span class="p">).</span>        <span class="c1">% not(A) already assumed</span>
<span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,[</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">)|</span><span class="nv">E</span><span class="p">]):-</span>  <span class="c1">% not(A) can be added to E</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E</span><span class="p">),</span>    <span class="c1">% if it&#39;s not already there,</span>
    <span class="nf">abducible</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>             <span class="c1">% if A is abducible</span>
    <span class="o">not</span> <span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>        <span class="c1">% and E doesn&#39;t explain A</span>
<span class="nf">abduce_not</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>     <span class="c1">% find explanation for A</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E0</span><span class="p">),</span>   <span class="c1">% should be consistent</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>

<span class="nf">abduce_not_l</span><span class="p">([],</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce_not_l</span><span class="p">([</span><span class="nv">B</span><span class="p">|</span><span class="nv">Bs</span><span class="p">],</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">abduce_not</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E1</span><span class="p">),</span>
    <span class="nf">abduce_not_l</span><span class="p">(</span><span class="nv">Bs</span><span class="p">,</span><span class="nv">E1</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
</pre></div>
</div>
<p>We illustrate the program on the following set of clauses. Notice that there are several explanations for <code class="docutils literal notranslate"><span class="pre">abnormal(tweety)</span></code>.</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-8-3-2">
<pre class="literal-block source swish" id="swish-8-3-2-code" source-text-end="
abducible(A):-
    A \= not(B),
    not cl(A,B)." source-text-start=":-op(900,fy,not).

abduce(O,E) :-abduce(O,[],E).

% abduce(O,E0,E) &lt;- E is abductive explanation of O, given
%                   E0 (works also for general programs)
abduce(true,E,E):-!.
abduce((A,B),E0,E):-!,
    abduce(A,E0,E1),
    abduce(B,E1,E).
abduce(A,E0,E):-
    cl(A,B),
    abduce(B,E0,E).
abduce(A,E,E):-
    element(A,E).           % already assumed
abduce(A,E,[A|E]):-
    not element(A,E),
    abducible(A),
    not abduce_not(A,E,E).  % and E doesn't explain not(A)
abduce(not(A),E0,E):-
    not element(A,E0),
    abduce_not(A,E0,E).

% abduce_not(O,E0,E) &lt;- E is abductive expl. of not(O)
abduce_not((A,B),E0,E):-!,
    abduce_not(A,E0,E);       % disjunction
    abduce_not(B,E0,E).
abduce_not(A,E0,E):-
    setof(B,cl(A,B),L),
    abduce_not_l(L,E0,E).
abduce_not(A,E,E):-
    element(not(A),E).        % not(A) already assumed
abduce_not(A,E,[not(A)|E]):-
    not element(not(A),E),
    abducible(A),
    not abduce(A,E,E).        % and E doesn't explain A
abduce_not(not(A),E0,E):-
    not element(not(A),E0),
    abduce(A,E0,E).

abduce_not_l([],E,E).
abduce_not_l([B|Bs],E0,E):-
    abduce_not(B,E0,E1),
    abduce_not_l(Bs,E1,E).

% element(X,Ys) &lt;- X is an element of the list Ys
element(X,[X|_Ys]).
element(X,[_Y|Ys]):-element(X,Ys).

">
<span></span><span class="nf">cl</span><span class="p">(</span><span class="nf">flies1</span><span class="p">(</span><span class="nv">X</span><span class="p">),(</span><span class="o">not</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">)),</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">))).</span>
<span class="nf">cl</span><span class="p">(</span><span class="nf">flies</span><span class="p">(</span><span class="nv">X</span><span class="p">),(</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="o">not</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">)))).</span>
<span class="nf">cl</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="nf">penguin</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span>
<span class="nf">cl</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="nf">dead</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span>
<span class="nf">cl</span><span class="p">(</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="nf">penguin</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span>
<span class="nf">cl</span><span class="p">(</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="nf">sparrow</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?- abduce(flies(tweety),Explanation).</span>
<span class="cm">?- abduce(flies1(tweety),Explanation).</span>
<span class="cm">*/</span></div>
</pre></div>
<p>The following queries show that the order of unnegated and negated literals in a clause only influences the order in which abducibles are added to the explanation, but not the explanation itself:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="nf">flies</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nv">Explanation</span><span class="p">).</span>
<span class="nv">Explanation</span> <span class="o">=</span>
    <span class="p">[</span><span class="o">not</span> <span class="nf">penguin</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="o">not</span> <span class="nf">dead</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nf">sparrow</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)]</span>

<span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="nf">flies1</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nv">Explanation</span><span class="p">).</span>
<span class="nv">Explanation</span> <span class="o">=</span>
    <span class="p">[</span><span class="nf">sparrow</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="o">not</span> <span class="nf">penguin</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="o">not</span> <span class="nf">dead</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)]</span>
</pre></div>
</div>
<div class="admonition exercise" id="ex-8-4">
<p class="admonition-title"><span class="caption-number">Exercise 8.4 </span><a class="headerlink" href="#ex-8-4" title="Permalink to this exercise">#</a></p>
<!--section 8.2-->
<p>The abductive meta-interpreter will loop on the program</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">wise</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="o">not</span> <span class="nf">teacher</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">teacher</span><span class="p">(</span><span class="s s-Atom">peter</span><span class="p">):-</span><span class="nf">wise</span><span class="p">(</span><span class="s s-Atom">peter</span><span class="p">).</span>
</pre></div>
</div>
<p>with the query <code class="docutils literal notranslate"><span class="pre">?-abduce(teacher(peter),E)</span></code> (see <a class="reference internal" href="8.2.html#sec-8-2"><span class="std std-numref">Section 8.2</span></a>). Change the interpreter such that this query is handled correctly, by adding <strong>all</strong> literals collected in the proof to the abductive explanation.</p>
</div>
<hr class="docutils" />
<p>Abduction can be used for formulating hypotheses about faulty components in a malfunctioning system. Here, the <span class="math notranslate nohighlight">\(Theory\)</span> is a description of the operation of the system, an <span class="math notranslate nohighlight">\(Observation\)</span> is a combination of input values and the observed output values, and <span class="math notranslate nohighlight">\(Explanation\)</span> is a <em>diagnosis</em>, telling us which components are malfunctioning. As an example we consider a logical circuit for adding three binary digits. Such a circuit can be built from two XOR-gates, two AND-gates, and an OR-gate (<a class="reference internal" href="#fig-8-3"><span class="std std-numref">Figure 8.3</span></a>). Its behaviour can be described logically as follows:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">adder</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">,</span><span class="nv">Sum</span><span class="p">,</span><span class="nv">Carry</span><span class="p">):-</span>
    <span class="nf">xor</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">S</span><span class="p">),</span>
    <span class="nf">xor</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">Sum</span><span class="p">),</span>
    <span class="nf">and</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">C1</span><span class="p">),</span>
    <span class="nf">and</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">C2</span><span class="p">),</span>
    <span class="nf">or</span><span class="p">(</span><span class="nv">C1</span><span class="p">,</span><span class="nv">C2</span><span class="p">,</span><span class="nv">Carry</span><span class="p">).</span>

<span class="nf">xor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>        <span class="nf">and</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>        <span class="nf">or</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>
<span class="nf">xor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>        <span class="nf">and</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>        <span class="nf">or</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">xor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>        <span class="nf">and</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>        <span class="nf">or</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">xor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>        <span class="nf">and</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>        <span class="nf">or</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
<figure class="align-default" id="fig-8-3">
<a class="reference internal image-reference" href="../../../_images/image0122.svg"><img alt="../../../_images/image0122.svg" src="../../../_images/image0122.svg" style="width: 75%;" /></a>
<figcaption>
<p><span class="caption-number">Figure 8.3 </span><span class="caption-text">A 3-bit adder.</span><a class="headerlink" href="#fig-8-3" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>These clauses describe the normal operation of the system. However, since diagnosis deals with faulty operation of components, we have to extend the system description with a so-called <em>fault model</em>. Such a fault model describes the behaviour of each component when it is in a faulty state. We distinguish two faulty states: the output of a component can be stuck at 0, or it can be stuck at 1. Faulty states are expressed by literals of the form <code class="docutils literal notranslate"><span class="pre">fault(Name=State)</span></code>, where <code class="docutils literal notranslate"><span class="pre">State</span></code> is either <code class="docutils literal notranslate"><span class="pre">s0</span></code> (stuck at 0) or <code class="docutils literal notranslate"><span class="pre">s1</span></code> (stuck at 1). The <code class="docutils literal notranslate"><span class="pre">Name</span></code> of a component is given by the system that contains it. Since components might be nested (e.g. the adder might itself be part of a circuit that adds two 8-bits binary numbers), the names of the components of a sub-system are prefixed by the name of that sub-system. This results in the following system description:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">adder</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">,</span><span class="nv">Sum</span><span class="p">,</span><span class="nv">Carry</span><span class="p">):-</span>
    <span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">S</span><span class="p">),</span>
    <span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="p">,</span><span class="nv">Z</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">Sum</span><span class="p">),</span>
    <span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">C1</span><span class="p">),</span>
    <span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="p">,</span><span class="nv">Z</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">C2</span><span class="p">),</span>
    <span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="s s-Atom">or1</span><span class="p">,</span><span class="nv">C1</span><span class="p">,</span><span class="nv">C2</span><span class="p">,</span><span class="nv">Carry</span><span class="p">).</span>

<span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">):-</span><span class="nf">xor</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">).</span>
<span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>
<span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>
<span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>
<span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>

<span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">):-</span><span class="nf">and</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">).</span>
<span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>
<span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>
<span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>
<span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>

<span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">):-</span><span class="nf">or</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">).</span>
<span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>
<span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>
<span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>
<span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>
</pre></div>
</div>
<p>Such a fault model, which includes all possible faulty behaviours, is called a <em>strong</em> fault model.</p>
<p>In order to diagnose the system, we declare <code class="docutils literal notranslate"><span class="pre">fault/1</span></code> as the (only) abducible predicate, and we make a call to <code class="docutils literal notranslate"><span class="pre">abduce/2</span></code>:</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-8-3-2-2">
<pre class="literal-block source swish" id="swish-8-3-2-2-code" source-text-end="
cl(A,B):-clause(A,B).

adder(N,X,Y,Z,Sum,Carry):-
    xorg(N-xor1,X,Y,S),
    xorg(N-xor2,Z,S,Sum),
    andg(N-and1,X,Y,C1),
    andg(N-and2,Z,S,C2),
    org(N-or1,C1,C2,Carry).

xorg(_N,X,Y,Z):-xor(X,Y,Z).
xorg(N,0,0,1):-fault(N=s1).
xorg(N,0,1,0):-fault(N=s0).
xorg(N,1,0,0):-fault(N=s0).
xorg(N,1,1,1):-fault(N=s1).

andg(_N,X,Y,Z):-and(X,Y,Z).
andg(N,0,0,1):-fault(N=s1).
andg(N,0,1,1):-fault(N=s1).
andg(N,1,0,1):-fault(N=s1).
andg(N,1,1,0):-fault(N=s0).

org(_N,X,Y,Z):-or(X,Y,Z).
org(N,0,0,1):-fault(N=s1).
org(N,0,1,0):-fault(N=s0).
org(N,1,0,0):-fault(N=s0).
org(N,1,1,0):-fault(N=s0).

xor(0,0,0).
xor(0,1,1).
xor(1,0,1).
xor(1,1,0).
or(0,0,0).
or(0,1,1).
or(1,0,1).
or(1,1,1).
and(0,0,0).
and(0,1,0).
and(1,0,0).
and(1,1,1)." source-text-start=":-op(900,fy,not).

abduce(O,E) :-abduce(O,[],E).

% abduce(O,E0,E) &lt;- E is abductive explanation of O, given
%                   E0 (works also for general programs)
abduce(true,E,E):-!.
abduce((A,B),E0,E):-!,
    abduce(A,E0,E1),
    abduce(B,E1,E).
abduce(A,E0,E):-
    cl(A,B),
    abduce(B,E0,E).
abduce(A,E,E):-
    element(A,E).           % already assumed
abduce(A,E,[A|E]):-
    not element(A,E),
    abducible(A),
    not abduce_not(A,E,E).  % and E doesn't explain not(A)
abduce(not(A),E0,E):-
    not element(A,E0),
    abduce_not(A,E0,E).

% abduce_not(O,E0,E) &lt;- E is abductive expl. of not(O)
abduce_not((A,B),E0,E):-!,
    abduce_not(A,E0,E);       % disjunction
    abduce_not(B,E0,E).
abduce_not(A,E0,E):-
    setof(B,cl(A,B),L),
    abduce_not_l(L,E0,E).
abduce_not(A,E,E):-
    element(not(A),E).        % not(A) already assumed
abduce_not(A,E,[not(A)|E]):-
    not element(not(A),E),
    abducible(A),
    not abduce(A,E,E).        % and E doesn't explain A
abduce_not(not(A),E0,E):-
    not element(not(A),E0),
    abduce(A,E0,E).

abduce_not_l([],E,E).
abduce_not_l([B|Bs],E0,E):-
    abduce_not(B,E0,E1),
    abduce_not_l(Bs,E1,E).

% element(X,Ys) &lt;- X is an element of the list Ys
element(X,[X|_Ys]).
element(X,[_Y|Ys]):-element(X,Ys).

">
<span></span><span class="nf">diagnosis</span><span class="p">(</span><span class="nv">Observation</span><span class="p">,</span><span class="nv">Diagnosis</span><span class="p">):-</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">Observation</span><span class="p">,</span><span class="nv">Diagnosis</span><span class="p">).</span>

<span class="nf">abducible</span><span class="p">(</span><span class="nf">fault</span><span class="p">(</span><span class="k">_</span><span class="nv">X</span><span class="p">)).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?- diagnosis(adder(a,0,0,1,0,1),D).</span>
<span class="cm">*/</span></div>
</pre></div>
<p>For instance, suppose the inputs <code class="docutils literal notranslate"><span class="pre">X=0</span></code>, <code class="docutils literal notranslate"><span class="pre">Y=0</span></code> and <code class="docutils literal notranslate"><span class="pre">Z=1</span></code> result in the outputs <code class="docutils literal notranslate"><span class="pre">Sum=0</span></code> and <code class="docutils literal notranslate"><span class="pre">Carry=1</span></code> (a double fault). In order to diagnose this behaviour, we formulate the following query:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">diagnosis</span><span class="p">(</span><span class="nf">adder</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="nv">D</span><span class="p">).</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">or1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">or1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">)];</span>
<span class="nv">No</span> <span class="s s-Atom">more</span> <span class="s s-Atom">solutions</span>
</pre></div>
</div>
<p>The first diagnosis is very obvious: it states that <code class="docutils literal notranslate"><span class="pre">or1</span></code> (which calculates <code class="docutils literal notranslate"><span class="pre">Carry</span></code>) is stuck at 1, and <code class="docutils literal notranslate"><span class="pre">xor2</span></code> (which calculates <code class="docutils literal notranslate"><span class="pre">Sum</span></code>) is stuck at 0. But the fault in the output of <code class="docutils literal notranslate"><span class="pre">or1</span></code> might also be caused by <code class="docutils literal notranslate"><span class="pre">and2</span></code> or <code class="docutils literal notranslate"><span class="pre">and1</span></code>, and even by both! The fifth diagnosis is an interesting one: if <code class="docutils literal notranslate"><span class="pre">xor1</span></code> is stuck at 1, this accounts for <strong>both</strong> faults in the outputs of the adder. The remaining three diagnoses are considerably less interesting, since each of them makes unnecessary assumptions about additional faulty components.</p>
<p>The predicate <code class="docutils literal notranslate"><span class="pre">diagnosis/2</span></code> generates every possible diagnosis; it does not make any assumptions about the relative plausibility of each of them. Several such assumptions can be made. For instance, we might be interested in the diagnoses with the least number of faulty components (there is only one smallest diagnosis in the example, but there may be several in general). Alternatively, we might want to consider only non-redundant or <em>minimal</em> diagnoses: those of which no proper subset is also a diagnosis. This is readily expressed in Prolog:</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-8-3-2-3">
<pre class="literal-block source swish" id="swish-8-3-2-3-code" source-text-end="
diagnosis(Observation,Diagnosis):-
    abduce(Observation,Diagnosis).

abducible(fault(_X)).

cl(A,B):-clause(A,B).

% remove_one(X,Ys,Zs) &lt;- Zs is list Ys minus one occurrence of X
remove_one(X,[X|Ys],Ys).
remove_one(X,[Y|Ys],[Y|Zs]):-remove_one(X,Ys,Zs).

% proper_subset(Xs,Ys) &lt;- Xs is a subset of Ys, and Ys contains
%                         at least one element more
proper_subset([],Ys):-Ys \= [].
proper_subset([X|Xs],Ys):-remove_one(X,Ys,Ys1),proper_subset(Xs,Ys1).

adder(N,X,Y,Z,Sum,Carry):-
    xorg(N-xor1,X,Y,S),
    xorg(N-xor2,Z,S,Sum),
    andg(N-and1,X,Y,C1),
    andg(N-and2,Z,S,C2),
    org(N-or1,C1,C2,Carry).

xorg(_N,X,Y,Z):-xor(X,Y,Z).
xorg(N,0,0,1):-fault(N=s1).
xorg(N,0,1,0):-fault(N=s0).
xorg(N,1,0,0):-fault(N=s0).
xorg(N,1,1,1):-fault(N=s1).

andg(_N,X,Y,Z):-and(X,Y,Z).
andg(N,0,0,1):-fault(N=s1).
andg(N,0,1,1):-fault(N=s1).
andg(N,1,0,1):-fault(N=s1).
andg(N,1,1,0):-fault(N=s0).

org(_N,X,Y,Z):-or(X,Y,Z).
org(N,0,0,1):-fault(N=s1).
org(N,0,1,0):-fault(N=s0).
org(N,1,0,0):-fault(N=s0).
org(N,1,1,0):-fault(N=s0).

xor(0,0,0).
xor(0,1,1).
xor(1,0,1).
xor(1,1,0).
or(0,0,0).
or(0,1,1).
or(1,0,1).
or(1,1,1).
and(0,0,0).
and(0,1,0).
and(1,0,0).
and(1,1,1)." source-text-start=":-op(900,fy,not).

abduce(O,E) :-abduce(O,[],E).

% abduce(O,E0,E) &lt;- E is abductive explanation of O, given
%                   E0 (works also for general programs)
abduce(true,E,E):-!.
abduce((A,B),E0,E):-!,
    abduce(A,E0,E1),
    abduce(B,E1,E).
abduce(A,E0,E):-
    cl(A,B),
    abduce(B,E0,E).
abduce(A,E,E):-
    element(A,E).           % already assumed
abduce(A,E,[A|E]):-
    not element(A,E),
    abducible(A),
    not abduce_not(A,E,E).  % and E doesn't explain not(A)
abduce(not(A),E0,E):-
    not element(A,E0),
    abduce_not(A,E0,E).

% abduce_not(O,E0,E) &lt;- E is abductive expl. of not(O)
abduce_not((A,B),E0,E):-!,
    abduce_not(A,E0,E);       % disjunction
    abduce_not(B,E0,E).
abduce_not(A,E0,E):-
    setof(B,cl(A,B),L),
    abduce_not_l(L,E0,E).
abduce_not(A,E,E):-
    element(not(A),E).        % not(A) already assumed
abduce_not(A,E,[not(A)|E]):-
    not element(not(A),E),
    abducible(A),
    not abduce(A,E,E).        % and E doesn't explain A
abduce_not(not(A),E0,E):-
    not element(not(A),E0),
    abduce(A,E0,E).

abduce_not_l([],E,E).
abduce_not_l([B|Bs],E0,E):-
    abduce_not(B,E0,E1),
    abduce_not_l(Bs,E1,E).

% element(X,Ys) &lt;- X is an element of the list Ys
element(X,[X|_Ys]).
element(X,[_Y|Ys]):-element(X,Ys).

">
<span></span><span class="nf">min_diagnosis</span><span class="p">(</span><span class="nv">O</span><span class="p">,</span><span class="nv">D</span><span class="p">):-</span>
    <span class="nf">diagnosis</span><span class="p">(</span><span class="nv">O</span><span class="p">,</span><span class="nv">D</span><span class="p">),</span>
    <span class="o">not</span><span class="p">((</span><span class="nf">diagnosis</span><span class="p">(</span><span class="nv">O</span><span class="p">,</span><span class="nv">D1</span><span class="p">),</span><span class="nf">proper_subset</span><span class="p">(</span><span class="nv">D1</span><span class="p">,</span><span class="nv">D</span><span class="p">))).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?- min_diagnosis(adder(a,0,0,1,0,1),D).</span>
<span class="cm">*/</span></div>
</pre></div>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">min_diagnosis</span><span class="p">(</span><span class="nf">adder</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="nv">D</span><span class="p">).</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">or1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">)];</span>
<span class="nv">No</span> <span class="s s-Atom">more</span> <span class="s s-Atom">solutions</span>
</pre></div>
</div>
<p>It should be noted that the predicate <code class="docutils literal notranslate"><span class="pre">min_diagnosis/2</span></code> is quite inefficient, since it needs time quadratic in the number of diagnoses (for each possible diagnosis, it generates in the worst case each possible diagnosis to see if the second is a proper subset of the first). In turn, the number of diagnoses is exponential in the number of components. More efficient ways of generating minimal diagnoses can be found in the literature; they fall outside the scope of this book.</p>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./src/text/3_part_iii"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

    <script>$(function() { $(".swish").LPN({swish:"https://swish.simply-logical.space/"}); });</script>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="8.2.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8.2. </span>The semantics of incomplete information</p>
      </div>
    </a>
    <a class="right-next"
       href="8.4.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">8.4. </span>The complete picture</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By <a href="mailto:Peter.Flach@bristol.ac.uk">Peter Flach</a> and <a href="mailto:K.Sokol@bristol.ac.uk">Kacper Sokol</a>, University of Bristol, United Kingdom

</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2015–2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  <p> This work is licenced under the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licence</a>. </p> <p> <a href="https://github.com/simply-logical/simply-logical/blob/master/LICENCE"><img src="https://img.shields.io/badge/Licence-CC%20BY--NC--SA%204.0-lightgrey.svg" alt="Licence"></a> &nbsp; &nbsp; &nbsp; <a href="https://doi.org/10.5281/zenodo.1156977"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.1156977.svg" alt="DOI"></a> </p> <p> This book discusses methods to implement intelligent reasoning by means of Prolog programs. The book is written from the shared viewpoints of Computational Logic, which aims at automating various kinds of reasoning, and Artificial Intelligence, which seeks to implement aspects of intelligent behaviour on a computer. </p>

</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>
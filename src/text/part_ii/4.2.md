<!--H3: Section 4.2-->
# Graphs generated by a predicate #

In the preceding section, a tree was represented by a Prolog term. This is convenient for relatively small trees such as proof trees, that are processed and passed around as a unit. However, for bigger trees it is a better idea not to represent them explicitly by a Prolog term, but implicitly by a set of ground facts, listing the arcs in the graph. An additional advantage of this representation is the possibility of representing graphs that are not trees.

+++

As an example of this representation, the tree in {numref}`fig:4.2` would be represented by the following facts:
```Prolog
arc(1,2).
arc(1,3).
arc(2,4).
arc(2,5).
arc(2,6).
arc(5,7).
arc(3,8).
arc(3,9).
arc(9,10).
```
The predicate for finding a path in a graph now needs a few minor adjustments: the graph is not passed on as an argument, and `arc/2` is used rather than `term_arc/2`:
```{swish} 4.2.1
---
source-text-start: 4.2.1-2-start
---
```

```{exercise} 4.4
Draw the SLD-tree for the query `?-path([1|Path])`.
```

+++

`path/2` will generate paths between any two connected nodes. When searching a graph such as an SLD-tree, we are normally only interested in paths which start at a given node (for instance, the root of a tree), and end in a leaf. The following program will do the job. Note that this program differs from the previous one in that it allows for paths consisting of one node only.
```{swish} 4.2.2
---
source-text-start: 4.2.1-2-start
---
```
The query `?-path_leaf(1,Path)` will lead to the following answers:
```Prolog
Path = [1,2,4];
Path = [1,2,5,7];
Path = [1,2,6];
Path = [1,3,8];
Path = [1,3,9,10];
No more solutions
```

```{exercise} 4.5
Draw the SLD-tree for this query.
```

+++

Notice the order in which the paths to the leafs are found -- the longer path `[1,2,5,7]` is found before the shorter path `[1,2,6]`. This kind of search is called *depth-first search*, because the deepest unvisited nodes are preferred. In contrast, *breadth-first search* tries all nodes on a given level before going one level deeper; consequently, shortest paths are found first. Of course, the order in which nodes are visited can only be understood procedurally -- logically speaking, there is nothing in the program which prescribes such an order. It is only because Prolog itself searches the SLD-tree in a depth-first fashion, that programs like the above perform depth-first search.

+++

---

+++

In real life, graphs are often infinite. For instance, many SLD-trees are infinite, even for very simple programs such as ('br' abbreviates brother):
```Prolog
br(X,Y):-br(X,Z),br(Z,Y).
br(paul,peter).
```
SLD-trees are graphs, with resolvents as nodes. Representing a resolvent by the list of its literals, we would need an infinite number of facts to represent SLD-trees, for instance:
```Prolog
arc([br(paul,B)],[br(paul,Z),br(Z,B)]).
arc([br(paul,B)],[]).
arc([br(paul,Z),br(Z,B)],[br(paul,Z1),br(Z1,Z),br(Z,B)]).
arc([br(paul,Z),br(Z,B)],[br(peter,B)]).
arc([br(paul,Z),br(Z,B)],[br(paul,paul)]).
...
arc([br(peter,B)],[br(peter,Z),br(Z,B)]).
...
arc([br(paul)],[br(paul,Z),br(Z,paul)]).
...
```
In such cases, it is a better idea to write a program which **generates** these facts. In other words, we need a logical definition of `arc/2`.

```{exercise} 4.6
Sketch the SLD-tree for the query `?-br(paul,B)`.
```

+++

Now, `arc(A,B)` is true if `A` and `B` are lists of negative literals interpreted as resolvents, and one resolution step applied to `A` and a clause for `br/2` yields `B`. We can write this down by means of the predicate `resolve/3`, which performs one resolution step, and the two clauses for `br/2` in the appropriate representation. This gives the following program:
```{swish} 4.2.3
```
The query `?-arc([br(paul,B)],N)` results in the answers
```Prolog
B = Y
N = [br(paul,Z),br(Z,Y)];

B = peter
N = []
```
as expected.

+++

Note that a query of the form `?-arc(R,[])` asks for a path from `R` to a success branch in the SLD-tree, thus simulating a query `:-R`. That is, the above program for `arc/2` is simply a meta-interpreter (with the object-level program hardwired in its clauses). In section 5.3, we encounter a similar meta-interpreter for full clausal logic.

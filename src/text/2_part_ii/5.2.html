
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>5.2. Depth-first search &#8212; Simply Logical</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-prolog.css?v=c1617293" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jquery-ui.min.css?v=711a7f8d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/lpn.css?v=a05dc249" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sl.css?v=3011a09a" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=a6b63e94"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script src="../../../_static/jquery.js?v=3d1d8b85"></script>
    <script src="../../../_static/jquery-ui.min.js?v=27a1b71a"></script>
    <script src="../../../_static/lpn.js?v=199b1815"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-JFZBHCMB8V"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-JFZBHCMB8V');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-JFZBHCMB8V');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'src/text/2_part_ii/5.2';</script>
    <link rel="icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="5.3. Breadth-first search" href="5.3.html" />
    <link rel="prev" title="5.1. A general search procedure" href="5.1.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../simply-logical.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/SL.svg" class="logo__image only-light" alt=""/>
    <img src="../../../_static/SL.svg" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">Simply Logical</p>
  
</a></div>
        <div class="sidebar-primary-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/simply-logical/simply-logical/blob/master/LICENCE" title="Licence" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="https://img.shields.io/badge/Licence-CC%20BY--NC--SA%204.0-lightgrey.svg" class="icon-link-image" alt="Licence"/></a>
        </li>
</ul></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../simply-logical.html">
                    Simply Logical
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../0_preface/_preface.html">Preface</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../1_part_i/_part_i.html">I. Logic and Logic Programming</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../1_part_i/1.0.html">1. A brief introduction to clausal logic</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/1.1.html">1.1. Answering queries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/1.2.html">1.2. Recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/1.3.html">1.3. Structured terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/1.4.html">1.4. What else is there to know about clausal logic?</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../1_part_i/2.0.html">2. Clausal logic and resolution: theoretical backgrounds</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.1.html">2.1. Propositional clausal logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.2.html">2.2. Relational clausal logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.3.html">2.3. Full clausal logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.4.html">2.4. Definite clause logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.5.html">2.5. The relation between clausal logic and Predicate Logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/2.6.html">2.6. Further reading</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../1_part_i/3.0.html">3. Logic Programming and Prolog</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.1.html">3.1. SLD-resolution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.2.html">3.2. Pruning the search by means of cut</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.3.html">3.3. Negation as failure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.4.html">3.4. Other uses of cut</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.5.html">3.5. Arithmetic expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.6.html">3.6. Accumulators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.7.html">3.7. Second-order predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.8.html">3.8. Meta-programs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.9.html">3.9. A methodology of Prolog programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1_part_i/3.10.html">3.10. Further reading</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="_part_ii.html">II. Reasoning with structured knowledge</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2 has-children"><a class="reference internal" href="4.0.html">4. Representing structured knowledge</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="4.1.html">4.1. Trees as terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="4.2.html">4.2. Graphs generated by a predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="4.3.html">4.3. Inheritance hierarchies</a></li>
<li class="toctree-l3"><a class="reference internal" href="4.4.html">4.4. Further reading</a></li>
</ul>
</details></li>
<li class="toctree-l2 current active has-children"><a class="reference internal" href="5.0.html">5. Searching graphs</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="5.1.html">5.1. A general search procedure</a></li>
<li class="toctree-l3 current active"><a class="current reference internal" href="#">5.2. Depth-first search</a></li>
<li class="toctree-l3"><a class="reference internal" href="5.3.html">5.3. Breadth-first search</a></li>
<li class="toctree-l3"><a class="reference internal" href="5.4.html">5.4. Forward chaining</a></li>
<li class="toctree-l3"><a class="reference internal" href="5.5.html">5.5. Further reading</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="6.0.html">6. Informed search</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="6.1.html">6.1. Best-first search</a></li>
<li class="toctree-l3"><a class="reference internal" href="6.2.html">6.2. Optimal best-first search</a></li>
<li class="toctree-l3"><a class="reference internal" href="6.3.html">6.3. Non-exhaustive informed search</a></li>
<li class="toctree-l3"><a class="reference internal" href="6.4.html">6.4. Further reading</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../3_part_iii/_part_iii.html">III. Advanced reasoning techniques</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../3_part_iii/7.0.html">7. Reasoning with natural language</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/7.1.html">7.1. Grammars and parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/7.2.html">7.2. Definite Clause Grammars</a></li>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/7.3.html">7.3. Interpretation of natural language</a></li>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/7.4.html">7.4. Further reading</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../3_part_iii/8.0.html">8. Reasoning with incomplete information</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/8.1.html">8.1. Default reasoning</a></li>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/8.2.html">8.2. The semantics of incomplete information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/8.3.html">8.3. Abduction and diagnostic reasoning</a></li>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/8.4.html">8.4. The complete picture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/8.5.html">8.5. Further reading</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../3_part_iii/9.0.html">9. Inductive reasoning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/9.1.html">9.1. Generalisation and specialisation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/9.2.html">9.2. Bottom-up induction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/9.3.html">9.3. Top-down induction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../3_part_iii/9.4.html">9.4. Further reading</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../appendices/_appendices.html">Additional materials</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../appendices/a_0.html">10. A catalogue of useful predicates</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../appendices/a_1.html">10.1. Built-in predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/a_2.html">10.2. A library of utility predicates</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../appendices/b_0.html">11. Two programs for logical conversion</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../appendices/b_1.html">11.1. From Predicate Logic to clausal logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/b_2.html">11.2. Predicate Completion</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../appendices/c_0.html">12. Answers to selected exercises</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_1.html">12.1. A brief introduction to clausal logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_2.html">12.2. Clausal logic and resolution: theoretical backgrounds</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_3.html">12.3. Logic Programming and Prolog</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_4.html">12.4. Representing structured knowledge</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_5.html">12.5. Searching graphs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_6.html">12.6. Informed search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_7.html">12.7. Reasoning with natural language</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_8.html">12.8. Reasoning with incomplete information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../appendices/c_9.html">12.9. Inductive reasoning</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference external" href="https://simply-logical.space/">Simply Logical Organisation</a></li>
<li class="toctree-l1"><a class="reference external" href="http://people.cs.bris.ac.uk/~flach/SimplyLogical.html">Original Book Home</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/simply-logical/simply-logical" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/simply-logical/simply-logical/edit/master/src/text/2_part_ii/5.2.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/simply-logical/simply-logical/issues/new?title=Issue%20on%20page%20%2Fsrc/text/2_part_ii/5.2.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/src/text/2_part_ii/5.2.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Depth-first search</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <!--H3: Section 5.2-->
<section class="tex2jax_ignore mathjax_ignore" id="depth-first-search">
<span id="sec-5-2"></span><h1><span class="section-number">5.2. </span>Depth-first search<a class="headerlink" href="#depth-first-search" title="Link to this heading">#</a></h1>
<p>We obtain a depth-first search strategy if the agenda is implemented as a last in–first out datastructure. The obvious way to do this in Prolog is to represent the agenda by a list of nodes, and to add and remove nodes from the front of the list:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% depth-first search</span>
<span class="nf">search_df</span><span class="p">([</span><span class="nv">Goal</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">goal</span><span class="p">(</span><span class="nv">Goal</span><span class="p">).</span>
<span class="nf">search_df</span><span class="p">([</span><span class="nv">Current</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">children</span><span class="p">(</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Children</span><span class="p">),</span>
    <span class="nf">append</span><span class="p">(</span><span class="nv">Children</span><span class="p">,</span><span class="nv">Rest</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">),</span>
    <span class="nf">search_df</span><span class="p">(</span><span class="nv">NewAgenda</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">children/2</span></code> predicate finds all children of a given node. If arcs in the search space are defined as before by the <code class="docutils literal notranslate"><span class="pre">arc/2</span></code> predicate, we could define <code class="docutils literal notranslate"><span class="pre">children/2</span></code> as</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">children</span><span class="p">(</span><span class="nv">Node</span><span class="p">,</span><span class="nv">Children</span><span class="p">):-</span>
    <span class="nf">findall</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span><span class="nf">arc</span><span class="p">(</span><span class="nv">Node</span><span class="p">,</span><span class="nv">C</span><span class="p">),</span><span class="nv">Children</span><span class="p">).</span>
</pre></div>
</div>
<p>In this way, all children of the current node are generated and stored on the agenda before examining the next node.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Here is an example of using depth-first search to find palindromes ending in a given series of letters.
(This is just for illustrative purposes, as a much better algorithm would be to extend the given letters with a prefix, reverse the extended string and append the two together.)
Note the depth bound is needed to get any answers at all.</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-search-df">
<pre class="literal-block source swish" id="swish-search-df-code" source-text-start="search_df([Goal|_Rest],Goal):-
    goal(Goal).
search_df([Current|Rest],Goal):-
    children(Current,Children),
    append(Children,Rest,NewAgenda),
    search_df(NewAgenda,Goal).

children(Node,Children):-
    findall(C,arc(Node,C),Children).

">
<span></span><span class="c1">% nodes are lists of letters</span>
<span class="nf">arc</span><span class="p">(</span><span class="nv">T</span><span class="p">,[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">]):-</span>
    <span class="nf">length</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span><span class="nv">N</span><span class="p">),</span><span class="nv">N</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">,</span>     <span class="c1">% this sets a depth bound</span>
    <span class="nf">member</span><span class="p">(</span><span class="nv">H</span><span class="p">,[</span><span class="s s-Atom">a</span><span class="p">,</span><span class="s s-Atom">d</span><span class="p">,</span><span class="s s-Atom">i</span><span class="p">,</span><span class="s s-Atom">m</span><span class="p">]).</span>  <span class="c1">% only use these letters</span>

<span class="c1">% find palindromes</span>
<span class="nf">goal</span><span class="p">(</span><span class="nv">L</span><span class="p">):-</span>
    <span class="nf">reverse</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span><span class="nv">L</span><span class="p">).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?-search_df([[a,d,a,m]],Goal).</span>
<span class="cm">*/</span></div>
</pre></div>
</div>
<p>This depth-first search program can be refined in several ways, of which we will consider two: returning a path to the goal, and loop detection. In the above implementation, it is impossible to return a path if we discover a goal node on the agenda, because we do not know how that goal node was reached. Instead of putting a single node on the agenda, we will store a complete path to that node. This is simply accomplished by changing the <code class="docutils literal notranslate"><span class="pre">children/2</span></code> predicate as follows:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">children</span><span class="p">([</span><span class="nv">Node</span><span class="p">|</span><span class="nv">Path</span><span class="p">],</span><span class="nv">Children</span><span class="p">):-</span>
    <span class="nf">findall</span><span class="p">([</span><span class="nv">C</span><span class="p">,</span><span class="nv">Node</span><span class="p">|</span><span class="nv">Path</span><span class="p">],</span><span class="nf">arc</span><span class="p">(</span><span class="nv">Node</span><span class="p">,</span><span class="nv">C</span><span class="p">),</span><span class="nv">Children</span><span class="p">).</span>
</pre></div>
</div>
<p>Of course, the <code class="docutils literal notranslate"><span class="pre">goal/1</span></code> predicate must be changed accordingly, because its argument is now a path instead of a single node. A query now takes the form</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">search_df</span><span class="p">([[</span><span class="nv">InitialNode</span><span class="p">]],</span><span class="nv">PathToGoal</span><span class="p">).</span>
</pre></div>
</div>
<p>The second refinement concerns loop detection. In order to check whether a node has been investigated before, we must maintain a list of visited nodes. We only add nodes to the agenda which do not already occur on this list (or on the agenda):</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% depth-first search with loop detection</span>
<span class="nf">search_df_loop</span><span class="p">([</span><span class="nv">Goal</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">goal</span><span class="p">(</span><span class="nv">Goal</span><span class="p">).</span>
<span class="nf">search_df_loop</span><span class="p">([</span><span class="nv">Current</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">children</span><span class="p">(</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Children</span><span class="p">),</span>
    <span class="nf">add_df</span><span class="p">(</span><span class="nv">Children</span><span class="p">,</span><span class="nv">Rest</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">),</span>
    <span class="nf">search_df_loop</span><span class="p">(</span><span class="nv">NewAgenda</span><span class="p">,[</span><span class="nv">Current</span><span class="p">|</span><span class="nv">Visited</span><span class="p">],</span><span class="nv">Goal</span><span class="p">).</span>

<span class="nf">add_df</span><span class="p">([],</span><span class="nv">Agenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">Agenda</span><span class="p">).</span>
<span class="nf">add_df</span><span class="p">([</span><span class="nv">Child</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,[</span><span class="nv">Child</span><span class="p">|</span><span class="nv">NewAgenda</span><span class="p">]):-</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="nv">Child</span><span class="p">,</span><span class="nv">OldAgenda</span><span class="p">),</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="nv">Child</span><span class="p">,</span><span class="nv">Visited</span><span class="p">),</span>
    <span class="nf">add_df</span><span class="p">(</span><span class="nv">Rest</span><span class="p">,</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">).</span>
<span class="nf">add_df</span><span class="p">([</span><span class="nv">Child</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">):-</span>
    <span class="nf">element</span><span class="p">(</span><span class="nv">Child</span><span class="p">,</span><span class="nv">OldAgenda</span><span class="p">),</span>
    <span class="nf">add_df</span><span class="p">(</span><span class="nv">Rest</span><span class="p">,</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">).</span>
<span class="nf">add_df</span><span class="p">([</span><span class="nv">Child</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">):-</span>
    <span class="nf">element</span><span class="p">(</span><span class="nv">Child</span><span class="p">,</span><span class="nv">Visited</span><span class="p">),</span>
    <span class="nf">add_df</span><span class="p">(</span><span class="nv">Rest</span><span class="p">,</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">).</span>
</pre></div>
</div>
<p>Note that the combination of loop detection and path construction allows the following optimisation: instead of maintaining complete paths to a node on the agenda and the list of visited nodes, we only store a node together with its parent. Once we encounter a goal, all its parents are on the list of visited nodes, which allows us to reconstruct the path.</p>
<div class="admonition exercise" id="ex-5-1">
<p class="admonition-title"><span class="caption-number">Exercise 5.1 </span><a class="headerlink" href="#ex-5-1" title="Permalink to this exercise">#</a></p>
<p>Modify the predicate <code class="docutils literal notranslate"><span class="pre">search_df_loop/3</span></code> such that it reconstructs the path to a goal in this way.</p>
</div>
<p>We now analyse depth-first search with respect to completeness, optimality and efficiency. A search strategy is <em>complete</em> if it is guaranteed to find every goal. Obviously, any exhaustive strategy is complete for finite search spaces. However, in an infinite search space depth-first search might get trapped in an infinite branch before having found all the solutions. For instance, reconsider the infinite SLD-tree in <a class="reference internal" href="../1_part_i/3.1.html#fig-3-2"><span class="std std-numref">Figure 3.2</span></a>. A left-to-right depth-first search strategy would dive deeper and deeper into the tree, taking the left branch at every node, and never find the goals in the branches to the right. So, <em>depth-first search is, in general, incomplete</em>. Since Prolog itself employs depth-first search, Prolog is also incomplete. Often, however, the incompleteness of Prolog can be avoided by reordering the clauses such that goals are found before infinite branches (for instance, by putting the recursive clause last), and to cut away the infinite parts of the search space.</p>
<p>If there is no cost function, a search strategy is optimal if it is guaranteed to reach any goal along the shortest path possible. The Staatsgalerie example already showed that this is not true for depth-first search: you found your friend but, while she was in a room next to your initial position, you finally reached that room through two other rooms. Thus, <em>depth-first search does not always find a shortest solution path</em>. Finally, we can estimate the memory requirements for depth-first search as follows. Suppose we are searching a tree in which each node has, on the average, <span class="math notranslate nohighlight">\(B\)</span> children. The number <span class="math notranslate nohighlight">\(B\)</span> is known as the <em>branching factor</em>. Generating the children of a node adds <span class="math notranslate nohighlight">\(B\)</span> nodes to the agenda. We are interested in the following question: if a goal is found at depth <span class="math notranslate nohighlight">\(n\)</span> (i.e. the path from the root to the goal has length <span class="math notranslate nohighlight">\(n\)</span>), how many nodes are there on the agenda? Since at each level only the children of a single node are generated, the size of the agenda is of the order <span class="math notranslate nohighlight">\(B \times n\)</span>, that is, a linear function of the depth of the tree. The time complexity of depth-first search is of the order <span class="math notranslate nohighlight">\(B^n\)</span>, since the runtime is proportional to the number of nodes searched, and in the worst case the goal is found in the last branch, after searching <span class="math notranslate nohighlight">\(B^n\)</span> nodes. Of course, we cannot hope to achieve any better for blind exhaustive search!</p>
<p>In practice, depth-first search is only implemented as above if loop detection is an absolute must. Otherwise, the agenda is represented <em>implicitly</em> by means of Prolog’s internal goal stack. Children of a given node are generated one at a time, by means of Prolog’s backtracking mechanism, and examined immediately upon generation:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% depth-first search by means of backtracking</span>
<span class="nf">search_bt</span><span class="p">(</span><span class="nv">Goal</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">goal</span><span class="p">(</span><span class="nv">Goal</span><span class="p">).</span>
<span class="nf">search_bt</span><span class="p">(</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">arc</span><span class="p">(</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Child</span><span class="p">),</span>
    <span class="nf">search_bt</span><span class="p">(</span><span class="nv">Child</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>
</pre></div>
</div>
<p>If there is a chance that the search program gets trapped in an infinite loop, it might be a good idea to employ a predefined <em>depth bound</em>:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% backtracking depth-first search with depth bound</span>
<span class="nf">search_d</span><span class="p">(</span><span class="nv">D</span><span class="p">,</span><span class="nv">Goal</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">goal</span><span class="p">(</span><span class="nv">Goal</span><span class="p">).</span>
<span class="nf">search_d</span><span class="p">(</span><span class="nv">D</span><span class="p">,</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nv">D</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="nv">D1</span> <span class="o">is</span> <span class="nv">D</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nf">arc</span><span class="p">(</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Child</span><span class="p">),</span>
    <span class="nf">search_d</span><span class="p">(</span><span class="nv">D1</span><span class="p">,</span><span class="nv">Child</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>
</pre></div>
</div>
<p>In this way the search process is guaranteed to halt, but solutions which appear beyond the depth bound are missed.</p>
<p><em>Iterative deepening</em> is a form of depth-first search which employs a depth bound that is increased on each iteration. That is, after performing a depth-first search with depth bound <span class="math notranslate nohighlight">\(d\)</span>, search starts all over again from the starting nodes with an increased depth bound <span class="math notranslate nohighlight">\(d + n\)</span>. The predicate <code class="docutils literal notranslate"><span class="pre">search_id/2</span></code> implements iterative deepening for <span class="math notranslate nohighlight">\(n = 1\)</span>.</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% iterative deepening</span>
<span class="nf">search_id</span><span class="p">(</span><span class="nv">First</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">search_id</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nv">First</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>     <span class="c1">% start with depth 1</span>

<span class="nf">search_id</span><span class="p">(</span><span class="nv">D</span><span class="p">,</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">search_d</span><span class="p">(</span><span class="nv">D</span><span class="p">,</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>
<span class="nf">search_id</span><span class="p">(</span><span class="nv">D</span><span class="p">,</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nv">D1</span> <span class="o">is</span> <span class="nv">D</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>                   <span class="c1">% increase depth</span>
    <span class="nf">search_id</span><span class="p">(</span><span class="nv">D1</span><span class="p">,</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Here is iterative deepening applied to the palindrome example. Note no depth bound is needed.
Also note that the query just provides the starting node, not an initial agenda, due to the use of backtracking search within iterative deepening (<code class="docutils literal notranslate"><span class="pre">search_d/3</span></code>).</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-search-id">
<pre class="literal-block source swish" id="swish-search-id-code" source-text-start="search_id(First,Goal):-
    search_id(1,First,Goal).     % start with depth 1

search_id(D,Current,Goal):-
    search_d(D,Current,Goal).
search_id(D,Current,Goal):-
    D1 is D+1,                   % increase depth
    search_id(D1,Current,Goal).

% backtracking depth-first search with depth bound
search_d(_D,Goal,Goal):-
    goal(Goal).
search_d(D,Current,Goal):-
    D&gt;0, D1 is D-1,
    arc(Current,Child),
    search_d(D1,Child,Goal).

children(Node,Children):-
    findall(C,arc(Node,C),Children).

">
<span></span><span class="c1">% nodes are lists of letters</span>
<span class="nf">arc</span><span class="p">(</span><span class="nv">T</span><span class="p">,[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">]):-</span>
    <span class="c1">%length(T,N),N&lt;11,           % depth bound no longer needed</span>
    <span class="nf">member</span><span class="p">(</span><span class="nv">H</span><span class="p">,[</span><span class="s s-Atom">a</span><span class="p">,</span><span class="s s-Atom">d</span><span class="p">,</span><span class="s s-Atom">i</span><span class="p">,</span><span class="s s-Atom">m</span><span class="p">]).</span>

<span class="c1">% find palindromes</span>
<span class="nf">goal</span><span class="p">(</span><span class="nv">L</span><span class="p">):-</span>
    <span class="nf">reverse</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span><span class="nv">L</span><span class="p">).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?-search_id([a,d,a,m],Goal).</span>
<span class="cm">*/</span></div>
</pre></div>
</div>
<p>A big advantage of iterative deepening over simple depth-first search is that iterative deepening is complete: it will find all the goals at depth <span class="math notranslate nohighlight">\(d\)</span> and less before proceeding to depth <span class="math notranslate nohighlight">\(d + n\)</span>. Moreover, if we set the depth increment <span class="math notranslate nohighlight">\(n\)</span> to <span class="math notranslate nohighlight">\(1\)</span>, iterative deepening is also optimal: it will find shorter paths first. A disadvantage of iterative deepening is that upper parts of the search space are searched more than once (and goals in those upper parts are found more than once as well).</p>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./src/text/2_part_ii"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

    <script>$(function() { $(".swish").LPN({swish:"https://swish.simply-logical.space/"}); });</script>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="5.1.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">5.1. </span>A general search procedure</p>
      </div>
    </a>
    <a class="right-next"
       href="5.3.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">5.3. </span>Breadth-first search</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By <a href="mailto:Peter.Flach@bristol.ac.uk">Peter Flach</a> and <a href="mailto:K.Sokol@bristol.ac.uk">Kacper Sokol</a>, University of Bristol, United Kingdom

</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2015–2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  <p> This work is licenced under the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licence</a>. </p> <p> <a href="https://github.com/simply-logical/simply-logical/blob/master/LICENCE"><img src="https://img.shields.io/badge/Licence-CC%20BY--NC--SA%204.0-lightgrey.svg" alt="Licence"></a> &nbsp; &nbsp; &nbsp; <a href="https://doi.org/10.5281/zenodo.1156977"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.1156977.svg" alt="DOI"></a> </p> <p> This book discusses methods to implement intelligent reasoning by means of Prolog programs. The book is written from the shared viewpoints of Computational Logic, which aims at automating various kinds of reasoning, and Artificial Intelligence, which seeks to implement aspects of intelligent behaviour on a computer. </p>

</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>